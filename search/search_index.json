{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>JDA is distributed through MavenCentral, allowing you an easy inclusion into your Java project by the dependency manager of your choice.</p>"},{"location":"#configuration","title":"Configuration","text":"MavenMaven (No Audio)GradleGradle (No Audio) <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n  &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n  &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n  &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n  &lt;version&gt;VERSION&lt;/version&gt;\n  &lt;exclusions&gt;\n    &lt;exclusion&gt;\n      &lt;groupId&gt;club.minnced&lt;/groupId&gt;\n      &lt;artifactId&gt;opus-java&lt;/artifactId&gt;\n    &lt;/exclusion&gt;\n  &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre> <pre><code>repositories {\n  mavenCentral()\n}\n\ndependencies {\n  implementation(\"net.dv8tion:JDA:VERSION\")\n}\n</code></pre> <pre><code>repositories {\n  mavenCentral()\n}\n\ndependencies {\n  implementation(\"net.dv8tion:JDA:VERSION\") {\n    exclude module: 'opus-java'\n  }\n}\n</code></pre>"},{"location":"contributing/contributing/","title":"Contribute towards JDA","text":""},{"location":"contributing/contributing/#setting-up-your-environment","title":"Setting up your Environment","text":"<ol> <li> <p>Create a Fork (If you already have a local repository skip to step 3)     </p> </li> <li> <p>Clone Repository</p> <pre><code>$ git clone https://github.com/ExampleName/JDA.git # (1)\nCloning into 'JDA'...\nremote: Counting objects: 15377, done.\nremote: Total 15377 (delta 0), reused 0 (delta 0), pack-reused 15377\nReceiving objects: 100% (15377/15377), 21.64 MiB | 2.36 MiB/s, done.\nResolving deltas: 100% (8584/8584), done.\nChecking connectivity... done.\n</code></pre> <ol> <li>Make sure to replace <code>ExampleName</code> with your GitHub Username.</li> </ol> </li> <li> <p>Move to your local repository (here <code>JDA</code>)</p> <pre><code>cd JDA\n</code></pre> </li> <li> <p>Configure upstream remote to keep your fork updated</p> <pre><code>$ git remote add upstream https://github.com/discord-jda/JDA.git\n</code></pre> </li> <li> <p>Create branch based on <code>upstream/master</code></p> <pre><code>$ git fetch upstream master\nFrom https://github.com/discord-jda/JDA\n * branch              master -&gt; FETCH_HEAD\n * [new branch]        master -&gt; upstream/master\n\n$ git checkout -b patch-1 upstream/master\nSwitched to a new branch 'patch-1'\n</code></pre> </li> </ol>"},{"location":"contributing/contributing/#making-changes","title":"Making Changes","text":"<p>Depending on your changes there are certain rules you have to follow if you expect your Pull Request to be merged.</p> <p>Note: It is recommended to create a new remote branch for each Pull Request based on the current <code>upstream/master</code> changes!</p> <ol> <li> <p>Adding a new Method or Class</p> <ul> <li>If your addition is not internal (e.g. an impl class or private method) you have to write documentation.<ul> <li>For that please follow the JavaDoc template</li> </ul> </li> <li>Keep your code consistent!<ul> <li>Follow the Structure Guide</li> <li>Compare your code style to the one used all over JDA and ensure you   do not break the consistency (if you find issues in the JDA style you can include and update it)</li> </ul> </li> </ul> <p>Example</p>  Bad Addition Good Addition <pre><code>+    public void reset() {\n+        name.reset();\n+        avatar.reset();\n+\n+        if (isType(AccountType.CLIENT)) {\n+            email.reset();\n+            password.reset();\n+        }\n+    }\n</code></pre> <pre><code>+    /*\n+     * Resets all {@link net.dv8tion.jda.core.managers.fields.AccountField Fields}\n+     * for this manager instance by calling\n+     * {@link net.dv8tion.jda.core.managers.fields.Field#reset() Field.reset()} sequentially\n+     */\n+    public void reset() \n+    {\n+        name.reset();\n+        avatar.reset();\n+\n+        if (isType(AccountType.CLIENT)) \n+        {\n+            email.reset();\n+            password.reset();\n+        }\n+    }\n</code></pre> </li> <li> <p>Making a Commit</p> <ul> <li>While having multiple commits can help the reader understand your changes, it might sometimes be   better to include more changes in a single commit.</li> <li>When you commit your changes write a proper commit caption which explains what you have done</li> </ul> </li> <li> <p>Updating your Fork</p> <ul> <li>Before you start committing make sure your fork is updated.   (See Syncing a Fork   or Keeping a Fork Updated)</li> </ul> </li> </ol>"},{"location":"contributing/contributing/#creating-a-pull-request","title":"Creating a Pull Request","text":"<ol> <li> <p>Commit your changes</p> <pre><code>$ git commit -am \"Updated Copyright in build.gradle\"\n[patch-1 340383d] Updated Copyright in build.gradle\n1 file changed, 1 insertion(+), 1 deletion(-)\n</code></pre> </li> <li> <p>Push your commits</p> <pre><code>$ git push origin patch-1\nCounting objects: 3, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (3/3), done.\nWriting objects: 100% (3/3), 313 bytes | 0 bytes/s, done.\nTotal 3 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), completed with 2 local objects.\nTo https://github.com/ExampleName/JDA.git\n * [new branch]      patch-1 -&gt; patch-1\n</code></pre> </li> <li> <p>Open Pull-Request</p> <p></p> </li> <li> <p>Set base branch to      <code>base fork: discord-jda/JDA</code> <code>base: master</code></p> </li> <li> <p>Allow edits from Maintainers</p> </li> <li> <p>Done! Just click Create pull request and await a review by one of the maintainers!</p> <p></p> </li> </ol>"},{"location":"contributing/repository-structure/","title":"Repository Structure","text":"<p>The structure of the JDA repository is heavily inspired from A Successful Git Branching Model</p>"},{"location":"contributing/repository-structure/#release-branch","title":"Release Branch","text":"<p>This branch represents the latest stable release. If a bug is found that requires immediate handling, a hotfix branch is to be based off of this branch and merged back into it.</p>"},{"location":"contributing/repository-structure/#release-candidate-branch","title":"Release Candidate Branch","text":"<p>The release candidate branches are forks of the development branch and are mainly used to prepare a release. The branch name is formatted as <code>release-x</code> where <code>x</code> would be the expected version.</p> <p>Based off: - development</p> <p>Merged into: - development - release</p>"},{"location":"contributing/repository-structure/#hotfix-branch","title":"Hotfix Branch","text":"<p>These branches are used to fix critical issues on the stable release and are to be merged right into master and development.</p> <p>If a release is in the process of being established and clashes versions, the version of the unmerged release is bumped.</p> <p>Based off: - release</p> <p>Merged into: - development - release</p>"},{"location":"contributing/repository-structure/#development-branch","title":"Development Branch","text":"<p>This is the core of the repository where all changes start. All Pull Requests are based off of this branch and merged back into it. Feature Branches should be forked from development and merged back into it.</p> <p>Merged into: - release</p>"},{"location":"contributing/repository-structure/#documentation-branch","title":"Documentation Branch","text":"<p>This is branch dedicated to updating the documentation. Since we build every change on <code>development</code>, we don't want to do a ton of \"Fix typo\" builds. For this reason we have this documentation branch.</p> <p>Merged into: - development</p>"},{"location":"contributing/repository-structure/#feature-branch","title":"Feature Branch","text":"<p>A feature branch should be used to develop a new feature for the library and should only deal with the core of the feature. Feature branches should not introduce breaking changes but may add deprecation. The branch name is formatted as <code>feature/x</code> where <code>x</code> would be the feature topic.</p> <p>Based off: - development</p> <p>Merged into: - development</p>"},{"location":"contributing/repository-structure/#experimental-branch","title":"Experimental Branch","text":"<p>An experimental branch changes core functionality of the library to a large extent and requires testing. The branch name is formatted as <code>experimental/x</code> where <code>x</code> would be the experiment topic.</p> <p>Based off: - development</p> <p>Merged into: - development</p>"},{"location":"contributing/structure-guide/","title":"How does JDA stay consistent in its code style and structure?","text":"<p>On this page we will try to concentrate all structure and code style guides that we ourself use in JDA to ensure consistency and readability.</p>"},{"location":"contributing/structure-guide/#indentation-and-brackets","title":"Indentation and Brackets","text":"<p>In JDA we use a specific brackets placement that is common for C# development. We put each <code>{</code> curly bracket on its own respective line:</p> <p>Note</p> <p>This rule goes for every curly bracket (open <code>{</code>/close <code>}</code>) and every scope usage such as try/catch/finally, loops, methods, lambda expressions, class scopes...</p> <pre><code>public void someMethod()\n{\n    this.works.well();\n    for (Each element : from()) // (1)\n    {\n        System.out.println(element);\n    }\n}\n</code></pre> <ol> <li>Always put a space in-between the scope usage and the opening bracket (i.e. <code>if (true)</code> and not <code>if(true)</code>)</li> </ol>"},{"location":"contributing/structure-guide/#indentation","title":"Indentation","text":"<p>We only use indentation of 4 spaces consistently throughout JDA. If a Pull Request does not use this indentation we will not accept it.</p>"},{"location":"contributing/structure-guide/#class-structure","title":"Class Structure","text":"<p>In this section we guide you through a logically ordered and structured class under JDA's point of view.</p>"},{"location":"contributing/structure-guide/#access-modifiers","title":"Access Modifiers","text":"<p>Access Modifiers are the keywords such as <code>public</code>, <code>protected</code> and <code>private</code>. They restrict other members from accessing these fields, methods or classes from locations throughout the library.</p> <p>When trying to order your fields, methods or nested classes we recommend using this logical order:</p> <ol> <li>Public Members</li> <li>Protected Members</li> <li>Private Members</li> <li>Package Private Members (no access modifier)</li> </ol> <p>In addition it is recommended to always put <code>static</code> fields and methods (not nested classes) first in your class. Fields marked with the <code>final</code> keyword should come first and should be separated from other fields. For better structure it is suggested to group fields by their declared types.</p>"},{"location":"contributing/structure-guide/#methods","title":"Methods","text":"<p>Methods are always defined after fields and the constructor of your class. There are 3 types of methods listed in logical order of appearance:</p> <ol> <li>Overriding or Implementing which make use of the <code>@Override</code> tag</li> <li>Internal (impl) setters which can be found in the impl classes of JDA.</li> <li>Object Overrides such as <code>toString</code>, <code>equals</code> and <code>hashCode</code></li> </ol>"},{"location":"contributing/structure-guide/#nested-classes","title":"Nested Classes","text":"<p>Nested classes no matter if <code>static</code> or member should always be placed at the very bottom of your class. These include enums and other class types. It is also recommended following the access modifier (see above sections) order here again.</p>"},{"location":"contributing/structure-guide/#imports-and-copyright","title":"Imports and Copyright","text":"<p>Every class in JDA has a Copyright Header (see example). Imports use wildcard <code>*</code> when they import 5+ classes from the same package.</p>"},{"location":"contributing/structure-guide/#javadoc","title":"JavaDoc","text":"<p>We put JavaDoc on the following targets:</p> <ul> <li>Public Methods that directly confront the JDA user</li> <li>Class level if the specific class has API features that the user can interact with such as an entity or manager</li> <li>Package docs, all not excluded packages require a <code>package-info.java</code> class with proper JavaDoc</li> </ul>"},{"location":"contributing/structure-guide/#paragraphs","title":"Paragraphs","text":"<p>JDA has a specific JavaDoc structure that is unique to our repository. We use a style in which we encapsulate each important part of the doc in a \"block\" for itself. Each <code>&lt;br&gt;</code> tag is placed in-front of the new line: </p> <p>Note</p> <p><code>&lt;br&gt;</code> tags are not to be closed</p> <pre><code>/**\n * This is my first line\n * &lt;br&gt;And this is my second line\n */\n</code></pre> <p>A new paragraph starts with <code>&lt;p&gt;</code> (not <code>&lt;br&gt;&lt;br&gt;</code>!). The <code>&lt;p&gt;</code> tag is supposed to be placed either between the previous and following paragraph or like the <code>&lt;br&gt;</code> tag directly in-front of the first line of that following paragraph:</p> <p>Note</p> <p>Do not close a paragraph tag! It is unnecessary and redundant.</p> <pre><code>/**\n * Either do this\n * \n * &lt;p&gt;Or do this\n * &lt;p&gt;\n * You can decide.\n */\n</code></pre>"},{"location":"contributing/structure-guide/#escaping","title":"Escaping","text":"<p>When you want to use characters that are not available in JavaDoc source most people tend to go with escaped characters such as <code>&amp;tm;</code>. In JDA we usually stick -if possible- to <code>{@literal \u2122}</code> for readability sake. When using this JavaDoc tag you must remember that it does not allow other nested tags since it will replace them with their literal characters instead! Another important tag you can use to achieve something that <code>&lt;code&gt;true&lt;/code&gt;</code> does you can use <code>{@code true}</code>. If you however want to also have nested links or other JavaDoc tags in your code snippet you can fallback to using the <code>&lt;code&gt;</code> tag: <pre><code>/**\n * JDA {@literal &gt;} All others\n * &lt;br&gt;Because we can do `{@code channel.sendMessage(\"hey\").queue()}` AND `{@code channel.sendMessage(\"hey\").complete()}`!\n * \n * &lt;p&gt;Or even do &lt;code&gt;channel.sendMessage(\"hey\").{@link net.dv8tion.jda.core.requests.RestAction#submit submit()}&lt;/code&gt;!!\n */\n</code></pre></p> <p>Note</p> <p>If you are using a tag like this, you have to close it!</p>"},{"location":"contributing/structure-guide/#linking","title":"Linking","text":"<p>If the class is not already imported, use the fully qualified name when you are linking to something through JavaDoc! Bad: <code>{@link RestAction}</code> Good: <code>{@link net.dv8tion.jda.core.requests.RestAction RestAction}</code></p> <p>Note</p> <p>We also highly recommend setting an alias name as you can see in the 2nd example snippet.</p> <p>When you link to an external resource (such as the official API docs) you can use the <code>&lt;a&gt;</code> tag to create a hyperlink. It is recommended to use the <code>target=\"_blank\"</code> tag. Example: <code>&lt;a href=\"https://github.com/discord-jda/JDA/releases/latest\" target=\"_blank\"&gt;Download JDA&lt;/a&gt;</code></p> <p>Hint: Sometimes it helps to link other methods in the description and then also including an <code>@see #otherMethod</code> at the very bottom.</p>"},{"location":"contributing/structure-guide/#case-restaction-return-type","title":"Case: RestAction return type","text":"<p>When your method makes use of RestAction you have to document possible <code>ErrorResponses</code> that can follow from this request:</p> <pre><code>/**\n * &lt;p&gt;The following {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses} are possible:\n * &lt;ul&gt;\n *     &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_ACCESS MISSING_ACCESS}\n *     &lt;br&gt;The request was attempted after the account lost access to the\n *         {@link net.dv8tion.jda.core.entities.Guild Guild} or {@link net.dv8tion.jda.client.entities.Group Group}\n *         typically due to being kicked or removed, or after {@link net.dv8tion.jda.core.Permission#MESSAGE_READ Permission.MESSAGE_READ}\n *         was revoked in the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}&lt;/li&gt;\n *\n *     &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS}\n *     &lt;br&gt;The send request was attempted after the account lost {@link net.dv8tion.jda.core.Permission#MESSAGE_WRITE Permission.MESSAGE_WRITE} in\n *         the {@link net.dv8tion.jda.core.entities.TextChannel TextChannel}.&lt;/li&gt;\n * &lt;/ul&gt;\n */\n</code></pre> <p>Note</p> <p>Always make these your last description paragraph Taken from: MessageChannel</p> <p>The <code>@return</code> for simple RestActions is as follows: <pre><code>/**\n * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: String\n *         &lt;br&gt;This is an -optional- description of what this RestAction will provide in case the type isn't enough\n */\n</code></pre></p>"},{"location":"contributing/structure-guide/#example-template","title":"Example Template","text":"<pre><code>    /**\n     * This description should inform the user about the basic function of the method (or class)\n     * that is being documented.\n     * &lt;br&gt;A line break should be placed at the beginning of the following line.\n     *\n     * &lt;p&gt;This description is optional and should contain additional / notable information about\n     * this method (or class)\n     *\n     * &lt;p&gt;All additional description paragraphs should start with the paragraph tag\n     * at the beginning of the new paragraph and should be separated from the previous\n     * paragraph by (at least) one line.\n     *\n     * &lt;p&gt;The last paragraph should point out what the possible {@link net.dv8tion.jda.core.requests.ErrorResponse ErrorResponses}\n     * are. These can occur in RestAction failures.\n     * &lt;br&gt;For that the following format should be used:\n     * &lt;ul&gt;\n     *     &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#UNKNOWN_MESSAGE UNKNOWN_MESSAGE}\n     *     &lt;br&gt;The Message did not exist (possibly deleted)&lt;/li&gt;\n     *\n     *     &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#INVALID_PIN INVALID_PIN}\n     *     &lt;br&gt;The message specified can not be pinned (possibly a system message)&lt;/li&gt;\n     *\n     *     &lt;li&gt;{@link net.dv8tion.jda.core.requests.ErrorResponse#MISSING_PERMISSIONS MISSING_PERMISSIONS}\n     *     &lt;br&gt;This can be caused if we do not hold one of the following Permissions:\n     *         &lt;ul&gt;\n     *             &lt;li&gt;{@link net.dv8tion.jda.core.Permission#MESSAGE_WRITE MESSAGE_WRITE}\n     *             &lt;br&gt;We are unable to send a message to this channel&lt;/li&gt;\n     *\n     *             &lt;li&gt;{@link net.dv8tion.jda.core.Permission#MESSAGE_READ MESSAGE_READ}\n     *             &lt;br&gt;We are unable to read messages in this channel&lt;/li&gt;\n     *         &lt;/ul&gt;&lt;/li&gt;\n     * &lt;/ul&gt;\n     *\n     * @param  var0 (1)\n     *         The Description should be at the same level as the parameter name\n     * @param  var1\n     *         Multiple parameters are to be documented in one \"block\"\n     *\n     * @throws javax.security.auth.login.LoginException\n     *         The same goes for descriptions of throwables\n     * @throws net.dv8tion.jda.core.exceptions.RateLimitedException\n     *         Multiple throwables are to be documented in one \"block\"\n     *\n     * @return {@link net.dv8tion.jda.core.requests.RestAction RestAction} - Type: {@link net.dv8tion.jda.core.entities.Role Role}\n     *         &lt;br&gt;The response type of the RestAction can be described further here.\n     *\n     * @see    Void\n     * @see    net.dv8tion.jda.core.JDA\n     *\n     * @since  3.0\n     *\n     * @serialData\n     *         If a tag is not specified here it should be at the bottom of the documentation.\n     *         &lt;br&gt;If the tag name is too long to follow the proper indentation formatting\n     *         it should start the block in the next line with the correct indentation.\n     */\n</code></pre> <ol> <li>We align each block with whitespace as you can see how <code>@param</code> is separated with 2 space characters from the actual parameter name</li> </ol>"},{"location":"introduction/events/","title":"Using Events","text":""},{"location":"introduction/events/#registering-your-listener","title":"Registering your Listener","text":"<p>To register your listener, we currently have 2 Systems. Annotated Listeners (AnnotatedEventManager) and Listeners implementing the Interface EventListener (InterfacedEventManager). By default, the Interfaced one is used.</p> <p>To switch between them, you can either use <code>JDABuilder#setEventManager(new AnnotatedEventManager())</code>, or <code>JDA#setEventManager(new MyEventManager())</code>.</p> <p>After that, you just need to call <code>JDABuilder#addEventListeners(Object...)</code> or <code>JDA#addEventListeners(Object...)</code> with your Listener implementation.</p> Using JDABuilder<pre><code>// imports {...}\npublic class Launcher\n{\n    public static void main(String[] arguments)\n    throws LoginException, InterruptedException\n    {\n        JDA api = JDABuilder.createDefault(arguments[0])\n                      .addEventListeners(new PingPongBot())\n                      .build().awaitReady();\n    }\n}\n</code></pre> Using JDA<pre><code>// imports {...}\npublic class MyListeners\n{\n    public static void registerPingPongListener(JDA api)\n    {\n        api.addEventListeners(new PingPongBot());\n    }\n}\n</code></pre>"},{"location":"introduction/events/#using-the-interfaced-system-default","title":"Using the Interfaced System (default)","text":"<p>When using the interfaced system (default), your Listener(s) have to implement the Interface EventListener, which only has a single function to implement: <code>public void onEvent(GenericEvent event)</code>.</p> <p>For convenience, we also included the class ListenerAdapter, which comes with a wide set of predefined functions targeted at specific event-types.</p> <p>Examples</p> <p>Using EventListener<pre><code>public class Test implements EventListener\n{\n    @Override\n    public void onEvent(GenericEvent event)\n    {\n        if(event instanceof MessageReceivedEvent)\n            System.out.println(event.getMessage().getContentDisplay());\n    }\n}\n</code></pre> Using ListenerAdapter<pre><code>public class Test extends ListenerAdapter\n{\n    @Override\n    public void onMessageReceived(MessageReceivedEvent event)\n    {\n        System.out.println(event.getMessage().getContentDisplay());\n    }\n}\n</code></pre> Don't forget actually registering this listener</p>"},{"location":"introduction/events/#using-the-annotated-system","title":"Using the Annotated System","text":"<p>When using the annotated system, all listener methods have to have the <code>@SubscribeEvent</code> annotation present, and only accept a single parameter, which has to be a instance of Event.</p> <p>Example</p> <p><pre><code>public class Test\n{\n    public static void main(String[] args)\n    throws LoginException\n    {\n        JDABuilder.createDefault(TOKEN)\n            .setEventManager(new AnnotatedEventManager())\n            .addEventListeners(new Test())\n            .build();\n    }\n\n    @SubscribeEvent\n    public void ohHeyAMessage(MessageReceivedEvent event)\n    {\n        System.out.println(event.getMessage().getContentDisplay());\n    }\n}\n</code></pre> Don't forget actually registering this listener</p>"},{"location":"introduction/faq/","title":"Frequently Asked Questions","text":"<p>Didn't find an answer? Try asking in our Discord server</p> What is a Guild? <p>In Discord API terminology a \"Guild\" is often used to refer to Discord servers with channels/roles/users</p> How do I make a bot account and add it to my server? <ol> <li>Create an application at: https://discord.com/developers/applications/me</li> <li>Create a bot account for that application</li> <li>Get the client id of your application</li> <li>Replace <code>CLIENT_ID</code> in this link: https://discord.com/api/oauth2/authorize?scope=bot&amp;client_id=CLIENT_ID</li> <li>Open the link, select your server and authorize the bot</li> </ol> How do I connect my bot? <ol> <li>Before you can connect you need to create a bot account</li> <li>Get the token of your bot</li> <li>Create your main class in an already setup project with JDA</li> <li>Supply the token to your JDABuilder instance and build! <pre><code>public static void main(String[] args) throws Exception\n{\n    JDABuilder.createDefault(THE_TOKEN).build();\n}\n</code></pre></li> </ol> Does this work with Kotlin? <p>Yes! This library makes use of the JSR-305 annotations to be as compatible as possible with Kotlin. To be more idiomatic, you can use extensions like JDA-KTX and JDA-reactor.</p> Why does method <code>XXX</code> not do anything? / What are RestActions? <p>When you use one of JDA's methods that interacts with Discord (like sending a message or retrieving data) and the method seems to have no effect (and no errors), chances are that you didn't use a RestAction properly or not at all. You can read about what a RestAction is and how to use it in the appropriate Wiki entry.</p> What is sharding? <p>When a bot reaches 2500 joined guilds, Discord will refuse to start a connection with it. In order to connect bots of a size like that it has to shard the load. It is recommended to have 1000 guilds per shard. More information can be found in our README.</p> How can I change the <code>Playing...</code>? <p>This is called a <code>Presence</code>and can be modified either before building JDA or at runtime. When building you can do <code>JDABuilder.setActivity(Activity.playing(\"Thrones\"))</code> and later change it using <code>JDA.getPresence().setActivity(...)</code>. In addition you may change the online status using <code>setStatus(OnlineStatus.INVISIBLE)</code> at the aforementioned locations.</p> <p>This may only be updated 5 times every 20 seconds and all other updates will be silently dropped by Discord.</p> What is an Custom Emoji and Unicode Emoji? <p>While there are a lot of standardized emojis (defined through Unicode spec), Discord allows Guilds to add their own emojis to be available. Those custom emojis are not just a plain Unicode character, but rather their own entity with id, name, ...</p> <p>To make this distinction more clear, we refer to the standard (Unicode) emojis as <code>UnicodeEmoji</code> and the Discord entities as <code>CustomEmoji</code> in JDA.</p> <p>You can create instances of this for use in various methods, such as reactions, using the factory methods of the <code>Emoji</code> interface. For instance, to create a unicode emoji instance, you use <code>Emoji.fromUnicode(\"...\")</code> with the string of unicode characters.</p> <p>To get the Unicode char(s) of some Emoji, you can either use a 3rd party library (such as emoji-java) or just look them up online. You can add reactions with 3 different formats:</p> <pre><code>// custom\nmessage.addReaction(Emoji.fromFormatted(\"&lt;:minn:245267426227388416&gt;\")).queue();\n// unicode escape\nmessage.addReaction(Emoji.fromUnicode(\"\\uD83D\\uDE02\")).queue();\n// codepoint notation\nmessage.addReaction(Emoji.fromUnicode(\"U+1F602\")).queue(); \n</code></pre> <ul> <li>Custom Emoji (<code>&lt;:name:id&gt;</code>)</li> <li>Unicode escape as UTF-16 characters (<code>\\uXXXX\\uXXXX</code>)</li> <li>Codepoint Notation as UTF-32 characters (<code>U+XXXXXXXXU+XXXXXXXX</code>)</li> </ul> Why is there a warning from SLF4J when starting up? <p>As of JDA 3.3.1, we use SLF4J for message logging. This means that you have to manually add any suitable SLF4J implementation library to your project.</p> <p>If your project does not have a SLF4J implementation library, following warning will be shown on startup: <pre><code>SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\n</code></pre></p> <p>We currently provide a fallback implementation to not lose logging completely in this case. This fallback does not allow for a lot of configuration and we suggest using a proper implementation instead.</p> <p>I recommend Logback. You can just add it to your Gradle/Maven file as extra dependency. There is a basic setup guide in our wiki available here: Logging Setup</p> What is the best way to delete messages from history? <p>You can use MessageChannel.getIterableHistory to get an instance of MessagePaginationAction which can be used to load messages in various ways such as takeAsync(amount) or takeUntilAsync(condition). This can be combined with MessageChannel.purgeMessages to bulk delete them from the channel. Keep in mind that <code>purgeMessages</code> will not delete all messages at once.</p> <p>Examples</p> <pre><code>// Delete a number of messages\nvoid deleteMessages(MessageChannel channel, int amount) {\nchannel.getIterableHistory()\n    .takeAsync(amount) // CompletableFuture&lt;List&lt;Message&gt;&gt;\n    .thenAccept(channel::purgeMessages); // bulk deletes the messages from the channel (if possible)\n}\n\n// Delete messages up to the specified time\nvoid deleteUntil(MessageChannel channel, OffsetDateTime time) {\nchannel.getIterableHistory()\n    .takeUntilAsync(message -&gt; message.getTimeCreated().isBefore(time)) // Collect messages until they pass the time condition\n    .thenAccept(channel::purgeMessages); // bulk deletes the messages from the channel (if possible)\n}\n\n// Delete a number of messages for a specific author (this can be abstracted to any condition)\nvoid deleteFromUser(MessageChannel channel, User author, int amount) {\nList&lt;Message&gt; messages = new ArrayList&lt;&gt;(); // First create a list for your messages\nchannel.getIterableHistory()\n    .forEachAsync(m -&gt; { // Loop over the history and filter messages\n    if (m.getAuthor().equals(author)) messages.add(m); // Add these messages to a list (your collector)\n    return messages.size() &lt; amount; // keep going until limit is reached (might be smart to also have a time condition here)\n    }) // This is also a CompletableFuture&lt;Void&gt; so you can chain a callback\n    .thenRun(() -&gt; channel.purgeMessages(messages)); // Run after loop is over, delete the messages in your list\n}\n</code></pre> How can I send a message to a specific channel without an event? <p>Since you decided that you want to send a message to a specific channel you should already have either an ID or the NAME and optionally GUILD (ID/NAME) to locate this channel. Now all you need is access to the JDA instance of your bot session. This can easily be accomplished by passing the JDA instance as a parameter to the constructor of your class.</p> <p>With the JDA instance you can easily acquire the specific channel through your means. One example is the getTextChannelById(id) method and the other is the getTextChannelsByName(name, true) method. Note that names might not be unique to one channel (example \"general\") so the <code>getTextChannelsByName(...)</code> method returns a <code>List&lt;TextChannel&gt;</code> containing all matches for that specific name. If you desire a specific guild you can filter by first getting the guild via either getGuildById(guildId) or getGuildsByName(guildName, true) and calling the same methods on the guilds rather than the JDA instance. It is not recommended to keep a reference to a Guild stored for long as the JDA cache might stop updating the specific instance in favor of a new one later on (for example when reconnecting).</p> <p>Example - Handling the JDA instance</p> <pre><code>public class EventChannel {\n    private final JDA api;\n\n    public EventChannel(JDA api) {\n        this.api = api;\n    }\n\n    public void start() { ... }\n}\n</code></pre> <p>Once you have this structure you have two choices of passing the JDA instance:</p> Ready Event (recommended)Awaiting Ready <pre><code>public static void main(String[] args) {\n    JDABuilder.createDefault(TOKEN)\n        .addEventListeners(listener) // some other listeners/settings\n        .addEventListeners(new ListenerAdapter() {\n            @Override public void onReady(ReadyEvent event) {\n                new EventChannel(event.getJDA()).start(); // starts your channel with the ready event\n            }\n        }).build();\n}\n</code></pre> <pre><code>public static void main(String[] args) {\n    JDA api = JDABuilder.createDefault(TOKEN)\n        .addEventListeners(listener) // some other listeners/settings\n        .build();\n    new EventChannel(api.awaitReady()).start();\n}\n</code></pre> How can I wait for a user response? <p>Since JDA is event based you can implement a finite state machine.</p> <p>See my stackoverflow answers:  - How to make a Discord Bot wait for a specific user to send a message with JDA? - Repetitive Consumer For Loop</p> How can I find out which RestAction causes an ErrorResponseException? <pre><code>RestAction.setPassContext(true); // enable context by default\nRestAction.DEFAULT_FAILURE = Throwable::printStackTrace;\n</code></pre> <p>Doing this will result in performance loss so it is recommended to only go to this extreme when you need to debug errors. To handle failures of a specific action, read this RestAction queue returned failure.</p> How do I test other builds? <p>You can use JitPack to provide other branches of JDA as a dependency.  We have a tutorial on how to use it on this wiki page.</p> How can I reduce the jar size of my bot? <p>To reduce the jar size of your bot you can either use Maven or Gradle. Alternatively use the minimized jar from the download server with the name <code>JDA-%VERSION%-withDependencies-min.jar</code></p> GradleMaven <ol> <li> <p>Exclude OPUS natives if you don't need encoding/decoding of audio (With LavaPlayer you don't need these natives)     <pre><code>implementation(\"net.dv8tion:JDA:$VERSION\") {\n    exclude module: \"opus-java\"\n}\n</code></pre>     For Kotlin DSL use <code>exclude(module=\"opus-java\")</code></p> </li> <li> <p>Minimize your Jar with the Shadow Plugin     <pre><code>shadowJar { minimize() }\n</code></pre></p> </li> </ol> <ol> <li> <p>Exclude OPUS natives if you don't need encoding/decoding of audio (With LavaPlayer you don't need these natives)         <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n    &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n    &lt;version&gt;$VERSION&lt;/version&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;club.minnced&lt;/groupId&gt;\n            &lt;artifactId&gt;opus-java&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> <li> <p>Minimize your Jar using the shade plugin     <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;\n    &lt;version&gt;3.2.1&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;minimizeJar&gt;true&lt;/minimizeJar&gt;\n    &lt;/configuration&gt;\n    &lt;executions&gt;\n    &lt;execution&gt;\n        &lt;phase&gt;package&lt;/phase&gt;\n        &lt;goals&gt;\n        &lt;goal&gt;shade&lt;/goal&gt;\n        &lt;/goals&gt;\n    &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre></p> </li> </ol> How can I reduce the memory footprint of my bot? <p>The default behavior of JDA is to cache everything except for messages. However, the library user can choose to disable some parts of the cache to decrease the memory impact of the bot process in exchange for less context and possibly more garbage accumulation.</p> <p>As of JDA 4.2.0 we use 3 factory methods to build JDA instances.</p> <ul> <li><code>createDefault</code> - Enables cache for users who are active in voice channels and all cache flags</li> <li><code>createLight</code> - Disables all user cache and cache flags</li> <li><code>create</code> - Enables member chunking, caches all users, and enables all cache flags</li> </ul> <p>You can do more configuration manually though:</p> <ol> <li> <p>Disable cache flags with <code>JDABuilder#disableCache(CacheFlag...)</code> This will disable certain cached entities such as the presences (activities) of users or channel permission overrides for members.</p> </li> <li> <p>Enable lazy loading with <code>JDABuilder#setChunkingFilter(ChunkingFilter.NONE)</code> This will only load members who actively participate in servers and not wait for users to load on startup.</p> </li> <li> <p>Disable Gateway Intents <code>JDABuilder#disabledIntents(EnumSet)</code> This will disable unused events from being received such as GUILD_MESSAGES_TYPING or similar.</p> </li> <li> <p>Disable Member Cache <code>JDABuilder#setMemberCachePolicy(MemberCachePolicy)</code> This will be used by JDA to decide whether to cache a member/user. You can use <code>NONE</code> to cache no users.</p> </li> <li> <p>Change the threading configuration with the pool setters:</p> <ol> <li><code>JDABuilder#setCallbackPool(ExecutorService)</code></li> <li><code>JDABuilder#setGatewayPool(ScheduledExecutorService)</code></li> <li><code>JDABuilder#setRateLimitPool(ScheduledExecutorService)</code></li> </ol> </li> </ol> How do I make a thread dump? <p>The JDK provides a utility for creating a thread dump of a running JVM process: <code>jstack -l &lt;pid&gt;</code> (that's an L for \"Long\") Example: <code>jstack -l 1337 &gt; dump.txt</code> This will list the thread dump and write it to a file called <code>dump.txt</code>.</p> <p>Tip</p> <p>You can get the PID using <code>jps -l</code>.</p> <p>You can also create a thread dump directly in IntelliJ:</p> <p></p> <p></p> <p>This will copy the thread dump to your clipboard and you can save it to a text file.</p>"},{"location":"introduction/jda/","title":"JDA (Java Discord API)","text":"<p>JDA strives to provide a clean and full wrapping of the Discord REST API and its Websocket-Events for Java.</p> <p>If you have any suggestions/questions/feedback for this wiki, please visit the #wiki-dev channel in the JDA Discord Server</p> <p>Examples</p> <pre><code>public class ReadyListener implements EventListener\n{\n    public static void main(String[] args)\n            throws InterruptedException\n    {\n        // Note: It is important to register your ReadyListener before building\n        JDA jda = JDABuilder.createDefault(\"token\")\n            .addEventListeners(new ReadyListener())\n            .build();\n\n        // optionally block until JDA is ready\n        jda.awaitReady();\n    }\n\n    @Override\n    public void onEvent(GenericEvent event)\n    {\n        if (event instanceof ReadyEvent)\n            System.out.println(\"API is ready!\");\n    }\n}\n</code></pre> <pre><code>public class MessageListener extends ListenerAdapter\n{\n    public static void main(String[] args)\n    {\n        JDA jda = JDABuilder.createDefault(\"token\")\n                .enableIntents(GatewayIntent.MESSAGE_CONTENT) // enables explicit access to message.getContentDisplay()\n                .build();\n        //You can also add event listeners to the already built JDA instance\n        // Note that some events may not be received if the listener is added after calling build()\n        // This includes events such as the ReadyEvent\n        jda.addEventListener(new MessageListener());\n    }\n\n    @Override\n    public void onMessageReceived(MessageReceivedEvent event)\n    {\n        if (event.isFromType(ChannelType.PRIVATE))\n        {\n            System.out.printf(\"[PM] %s: %s\\n\", event.getAuthor().getName(),\n                                    event.getMessage().getContentDisplay());\n        }\n        else\n        {\n            System.out.printf(\"[%s][%s] %s: %s\\n\", event.getGuild().getName(),\n                        event.getChannel().getName(), event.getMember().getEffectiveName(),\n                        event.getMessage().getContentDisplay());\n        }\n    }\n}\n</code></pre> <p>More Examples: We provide a small set of Examples in the Example Directory.</p>"},{"location":"introduction/jda/#download","title":"Download","text":"<p>You can get the latest released builds here: Promoted Downloads</p> <p>If you want the most up-to-date builds, you can get them here: Latest Build Downloads</p>"},{"location":"introduction/jda/#docs","title":"Docs","text":"<p>Javadocs are available in both jar format and web format. The jar format is available on the Promoted Downloads page or on any of the build pages of the legacy v4 Downloads or v5 Downloads.  The web format allows for viewing of the Latest Docs or legacy Docs  and also viewing of each individual build's javadoc. To view the javadoc for a specific build, you will need to go to the GitHub release for your version and download the javadoc jar for the specific build. Once you have the jar extract the files with the zip tool of your preference (winrar or 7zip, etc.) and open the <code>index.html</code> file with your internet browser.</p>"},{"location":"introduction/jda/#getting-help","title":"Getting Help","text":"<p>If you need help, or just want to talk with the JDA or other Devs, you can join the Official JDA Discord Guild.</p> <p>Alternatively you can also join the Unofficial Discord API Guild. Once you joined, you can find JDA-specific help in the <code>#java_jda</code> channel. The JDA specific server will often have faster responses than the <code>#java_jda</code> channel in the Discord API server.</p> <p>For guides and setup help you can also take a look at this wiki. Especially interesting are the Getting Started Pages.</p>"},{"location":"introduction/jda/#contributing-to-jda","title":"Contributing to JDA","text":"<p>If you want to contribute to JDA, make sure to base your branch off of our master branch (or a feature-branch) and create your PR into that same branch. We will be rejecting any PRs between branches or into release branches!</p> <p>It is also highly recommended to get in touch with the Devs before opening Pull Requests (either through an issue or the Discord servers mentioned above). It is very possible that your change might already be in development or you missed something.</p> <p>More information can be found at the wiki page Contributing</p>"},{"location":"introduction/jda/#dependencies","title":"Dependencies","text":"<p>This project requires Java 8. For other dependencies, see README</p>"},{"location":"introduction/migration-v3-v4/","title":"Migration Guide 3.X to 4.X","text":"<p>This version includes a number of breaking changes.</p>"},{"location":"introduction/migration-v3-v4/#extensions-that-support-4x","title":"Extensions That Support 4.X","text":"<p>Here is a list of known extensions that support 4.X. The ones that are not checked do not support it yet. You should check that everything used in your project supports 4.X before starting migration.</p> <ul> <li> jda-reactor</li> <li> LavaPlayer</li> <li> jda-nas (since 1.1.0)</li> <li> JDA-Utilities (since 3.0.1)</li> <li> Lavalink Client (since 4.0)</li> <li> JDAction (see #6)</li> </ul>"},{"location":"introduction/migration-v3-v4/#package-layout-changes","title":"Package layout changes","text":"<p>Since we removed the client-only features from JDA the package didn't make much sense anymore. Instead we have merged <code>core</code>, <code>bot</code>, and <code>client</code> into <code>api</code>. The new package prefix for the API functionality is now <code>net.dv8tion.jda.api</code>.</p> <p>If you used internal classes they will not be available under this prefix but instead use <code>net.dv8tion.jda.internal</code>. Something like <code>net.dv8tion.jda.core.entities.impl</code> has been moved to <code>net.dv8tion.jda.internal.entities</code> since the internal packages only contain implementations anyway.</p> <p>In the case that <code>PermissionUtil.checkPermissions</code> was used in your code, this should be changed to <code>member.hasPermission(...)</code> or <code>role.hasPermission(...)</code>.</p>"},{"location":"introduction/migration-v3-v4/#removed-features","title":"Removed Features","text":"<p>Almost everything from <code>net.dv8tion.jda.client</code> has been removed as its not supported by the API and can lead to account termination which we don't want to happen. Additionally, most of the features advertised by the interfaces in <code>client</code> were not even implemented or documented properly. Everything on <code>JDABot</code> has been moved into <code>JDA</code>.</p> <p>The flag to disable the audio system with <code>setAudioEnabled(false)</code> has been removed. This flag only enabled an exception for <code>Guild.getAudioManager()</code> which is unnecessary.</p> <p>The entire <code>net.dv8tion.jda.webhook</code> package has been moved to a dedicated library at https://github.com/MinnDevelopment/discord-webhooks</p> <p>The methods <code>buildBlocking</code> and <code>buildAsync</code> have been removed as they were already deprecated. To replace <code>buildBlocking</code> you should use <code>awaitReady()</code> on the <code>JDA</code> instance returned by <code>build()</code>.</p> <p>The overloads for <code>sendFile</code> that accepted a <code>Message</code> as their last parameter have been removed in favor of <code>MessageAction.addFile</code>. For example <code>sendFile(file, message)</code> becomes <code>sendMessage(message).addFile(file)</code>.</p> <p>Both <code>getWebSocketTrace</code> and <code>getCloudflareRays</code> have been removed without replacements. These are not officially supported by the Discord API and subject to change.</p>"},{"location":"introduction/migration-v3-v4/#renamed-classes","title":"Renamed Classes","text":"<p>Some classes have been renamed to better represent their meaning.</p> <ul> <li><code>Channel</code> -&gt; <code>GuildChannel</code></li> <li><code>Game</code> -&gt; <code>Activity</code> (also <code>CacheFlag.GAME</code> -&gt; <code>CacheFlag.ACTIVITY</code>)</li> <li><code>GuildMemberNickChangeEvent</code> -&gt; <code>GuildMemberUpdateNicknameEvent</code></li> </ul>"},{"location":"introduction/migration-v3-v4/#renamed-methods","title":"Renamed Methods","text":"<p>A few methods were renamed for better consistency and clarity.</p> <ul> <li><code>JDABuilder.addEventListener</code> -&gt; <code>JDABuilder.addEventListeners</code></li> <li><code>JDABuilder.setGame</code> -&gt; <code>JDABuilder.setActivity</code> (same for <code>Presence</code> and <code>DefaultShardManagerBuilder</code>)</li> <li><code>Invite.getURL</code> -&gt; <code>Invite.getUrl</code></li> <li><code>JDA.getPing</code> -&gt; <code>JDA.getGatewayPing</code></li> <li><code>JDA.getWebhookById</code> -&gt; <code>JDA.retrieveWebhookById</code></li> <li><code>Guild.getWebhooks</code> -&gt; <code>Guild.retrieveWebhooks</code> (same for <code>TextChannel</code>)</li> <li><code>Guild.getInvites</code> -&gt; <code>Guild.retrieveInvites</code> (same for <code>GuildChannel</code>)</li> <li><code>Guild.getAuditLogs</code> -&gt; <code>Guild.retrieveAuditLogs</code></li> <li><code>Guild.getBan[ById|List]</code> -&gt; <code>Guild.retrieveBan[ById|List]</code></li> <li><code>Guild.getVanityUrl</code> -&gt; <code>Guild.retrieveVanityUrl</code></li> <li><code>MessageChannel.getMessageById</code> -&gt; <code>MessageChannel.retrieveMessageById</code></li> <li><code>JDA.getApplicationInfo</code> -&gt; <code>JDA.retrieveApplicationInfo</code></li> <li><code>AudioManager.getReceiveHandler</code> -&gt; <code>AudioManager.getReceivingHandler</code></li> <li><code>GuildController.addSingleRoleToMember</code> -&gt; <code>Guild.addRoleToMember</code> (same for <code>removeSingleRoleFromMember</code>)</li> <li><code>GuildController.setNickname</code> -&gt; <code>Guild.modifyNickname</code></li> <li><code>GuildMemberNickChangeEvent.getPrevNick</code> -&gt; <code>GuildMemberUpdateNicknameEvent.getOldNickname</code></li> <li><code>GuildMemberNickChangeEvent.getNewNick</code> -&gt; <code>GuildMemberUpdateNicknameEvent.getNewNickname</code></li> <li><code>ISnowflake.getCreationTime</code> -&gt; <code>ISnowflake.getTimeCreated</code></li> </ul>"},{"location":"introduction/migration-v3-v4/#changed-functionality","title":"Changed Functionality","text":"<p>Some methods have changed their signature in a breaking way. This is supposed to improve either internal code or make the interface more versatile.</p>"},{"location":"introduction/migration-v3-v4/#jdabuilder-and-defaultshardmanagerbuilder","title":"JDABuilder and DefaultShardManagerBuilder","text":"<p>As of 4.2.0 the JDABuilder constructor has been deprecated in favor of 3 factory methods:</p> <ul> <li><code>createDefault</code></li> <li><code>createLight</code></li> <li><code>create</code></li> </ul> <p>Further details are explained in a dedicated wiki page here: Gateway Intents and Member Cache Policy</p>"},{"location":"introduction/migration-v3-v4/#permission-lists","title":"Permission Lists","text":"<p>Everything that once returned <code>List&lt;Permission&gt;</code> has been changed to return <code>EnumSet&lt;Permission&gt;</code> instead for a better representation.</p>"},{"location":"introduction/migration-v3-v4/#message-attachments","title":"Message Attachments","text":"<p>You can no longer use blocking operations to download attachments of a message. Instead we replaced the old <code>download()</code> with <code>downloadToFile()</code> and similar methods. These use <code>CompletableFuture</code> to provide continuations such as <code>thenAccept</code> and <code>whenComplete</code>. Examples are provided in the documentation for the respective methods.</p>"},{"location":"introduction/migration-v3-v4/#audio-system","title":"Audio System","text":"<p><code>AudioSendHandler.provide20MsAudio()</code> now returns <code>ByteBuffer</code> instead of <code>byte[]</code>. An easy transition is to use <code>ByteBuffer.wrap(byte[])</code>. This was done to allow re-using the same buffer for multiple packets instead of allocating a fitting array every time.</p>"},{"location":"introduction/migration-v3-v4/#permissionoverride","title":"PermissionOverride","text":"<p><code>PermissionOverride.getManager()</code> now returns a <code>PermissionOverrideAction</code> instead to remove code duplication. You can now also use <code>GuildChannel.upsertPermissionOverride</code> which will either return <code>getManager()</code> on an existing override or use <code>putPermissionOverride()</code> if there is no existing override.</p>"},{"location":"introduction/migration-v3-v4/#events","title":"Events","text":"<p><code>IEventManager.handle</code>, <code>EventListener.onEvent</code>, and <code>ListenerAdapter.onGenericEvent</code> now accepts <code>GenericEvent</code> which is a new interface that allows a more versatile hierarchy for the events it can handle. <code>UpdateEvent</code> is now a subinterface for <code>GenericEvent</code>.</p>"},{"location":"introduction/migration-v3-v4/#guildcontroller","title":"GuildController","text":"<p>The methods provided by the old <code>GuildController</code> class have been moved into the <code>Guild</code> interface. The <code>GuildController</code> has been removed completely. Additionally, <code>Member</code> received a few new shortcuts like <code>Member.ban(int)</code>.</p> <p>The methods <code>addRolesToMember</code> and <code>removeRolesFromMember</code> have been removed and should be replaced with <code>modifyMemberRoles</code>.</p>"},{"location":"introduction/migration-v3-v4/#messages","title":"Messages","text":"<p>Since we added <code>@Nonnull</code> and <code>@Nullable</code> annotations we had to compromise on conditional nullability. This means the methods like <code>Message.getTextChannel</code> now throw instead of returning <code>null</code> if the message was not sent in a <code>TextChannel</code>. You can use <code>Message.isFromType</code> to test for the channel type.</p>"},{"location":"introduction/migration-v3-v4/#compression","title":"Compression","text":"<p>To support other compression algorithms like <code>zstd</code> that Discord may offer in the future we changed <code>setCompressionEnabled</code> to <code>setCompression</code>. In this change we also replaced the <code>boolean</code> with a new enum for each algorithm. The new way to disable compression is <code>setCompression(Compression.NONE)</code>.</p>"},{"location":"introduction/migration-v3-v4/#restaction","title":"RestAction","text":"<p>All <code>RestAction</code> types have been changed to be interfaces to improve maintainability. Additionally, <code>submitAfter</code> now returns <code>DelayedCompletableFuture</code> to allow usage of continuations.</p>"},{"location":"introduction/migration-v4-v5/","title":"Migration Guide 4.X to 5.X","text":"<p>This version utilizes Discord API v10, and includes several breaking changes and improvements.</p>"},{"location":"introduction/migration-v4-v5/#dependency-installation","title":"Dependency Installation","text":"<p>Before continuing, we should mention that JDA versions are now distributed via Maven Central. You can remove the old <code>m2.dv8tion.net</code> resolver from your build files.</p> <p>Replace <code>VERSION</code> with the latest version </p> GradleMaven <pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"net.dv8tion:JDA:VERSION\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n  &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n  &lt;version&gt;VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"introduction/migration-v4-v5/#additional-resources","title":"Additional Resources","text":"<p>This migration guide does not include every single detail and does not focus on any new features available in JDA 5, such as ThreadChannels. Here are some useful resources to learn more if you are curious about all the new things we added:</p> <ul> <li>Examples</li> <li>JDA 5 Javadocs</li> <li>Releases</li> </ul>"},{"location":"introduction/migration-v4-v5/#extensions-that-support-5x","title":"Extensions That Support 5.X","text":"<p>Here is a list of known extensions that support 5.X. The ones that are not checked do not support it yet. You should check that everything used in your project supports 5.X before starting migration.</p> <ul> <li> jda-reactor</li> <li> LavaPlayer</li> <li> jda-nas<ul> <li> udpqueue.rs (for minimal Rust bindings)</li> </ul> </li> <li> jda-ktx</li> <li> JDA-Utilities</li> </ul>"},{"location":"introduction/migration-v4-v5/#introduction-of-message-content-privileged-intent","title":"Introduction of Message Content Privileged Intent","text":"<p>As part of upgrading to API v10, accessing the following user-generated content in messages now requires the Message Content privileged intent (<code>GatewayIntent.MESSAGE_CONTENT</code>):</p> <ul> <li>Text content (<code>Message#getContentRaw</code>, <code>Message#getContentDisplay</code>, <code>Message#getContentStripped</code>)</li> <li>Embeds (<code>Message#getEmbeds</code>)</li> <li>Attachments (<code>Message#getAttachments</code>)</li> <li>Message Components (<code>Message#getActionRows</code>, <code>Message#getButtons</code>)</li> <li>Custom Emoji Mentions (<code>Message#getMentions()#getCustomEmojis()</code>)</li> </ul> <p>You must enable this intent in your <code>JDABuilder</code> AND in the Discord Developer Portal for your app if you utilize any of the above methods. For more information on intents, read the dedicated wiki page.</p>"},{"location":"introduction/migration-v4-v5/#channel-rework","title":"Channel Rework","text":"<p>There are several breaking changes to <code>GuildChannel</code> and <code>ChannelManager</code>. Firstly, the packages of most channel interfaces have changed. What was previously simply found in <code>net.dv8tion.jda.api.entities</code> is now split over the following packages:</p> <ul> <li><code>net.dv8tion.jda.api.entities.channel</code>     Top level channel enums and the new <code>Channel</code> type interface.</li> <li><code>net.dv8tion.jda.api.entities.channel.attribute</code>     Interfaces dedicated to specific fields, such as slowmode or permissions. This also has some interfaces for concepts, such as copying or categorizing.</li> <li><code>net.dv8tion.jda.api.entities.channel.concrete</code>     The bottom level interfaces for exact concrete types, such as <code>VoiceChannel</code> and <code>TextChannel</code>.</li> <li><code>net.dv8tion.jda.api.entities.channel.forums</code>     Types related to <code>ForumChannel</code>, such as tags.</li> <li><code>net.dv8tion.jda.api.entities.channel.middleman</code>     Abstractions that apply to multiple concrete types, such as <code>MessageChannel</code> which covers all message related methods.</li> <li><code>net.dv8tion.jda.api.entities.channel.unions</code>     Interfaces used for return values, allowing for downcasting into specific types. They also provided shared features of the specific interface they extend.</li> </ul>"},{"location":"introduction/migration-v4-v5/#channel-return-types","title":"Channel Return Types","text":"<p>Many classes in JDA had specific getters for each channel type. For example, messages had <code>getTextChannel()</code> and <code>getPrivateChannel()</code>. The goal was to allow easy conversion to concrete types that have more functionality than their abstract counterpart (such as <code>MessageChannel</code>). In JDA v5, we've introduced new Channel Union interfaces to deal with this problem in a more elegant way. Instead of using <code>foo.getTextChannel()</code>, you now use <code>foo.getChannel().asTextChannel()</code>. The <code>getChannel()</code> method now often returns a specific Union type such as <code>MessageChannelUnion</code>, which doubles as the abstract implementation for <code>MessageChannel</code> (allows to send messages) and also downcasting via various <code>asX()</code> methods.</p>"},{"location":"introduction/migration-v4-v5/#new-channel-attribute-interfaces","title":"New Channel Attribute Interfaces","text":"<p><code>GuildChannel</code> now implements <code>getGuild</code> and <code>getManager</code> only. It's meant to serve as a generic type to hold channels from guilds.</p> <p>Specific channel attributes, such as slowmode and permissions, have been split into several interfaces. These interfaces can be found in the <code>net.dv8tion.jda.api.entities.channel.attribute</code> package. Each interface in this package extends <code>GuildChannel</code>.</p>"},{"location":"introduction/migration-v4-v5/#permission-access-changes","title":"Permission Access Changes","text":"<p>With JDA v5 we reduced the capabilities of the <code>GuildChannel</code> interface. The method <code>GuildChannel#getPermissionContainer</code> has been introduced to make accessing permissions easier. This allows for users to confidently access the entity that dictates the permissions for a given channel without having to check whether the channel actually supports permissions, such as in the case of threads.</p> <p>Of course, if you have a channel type that already supports <code>IPermissionContainer</code>, you don't need this getter.</p>"},{"location":"introduction/migration-v4-v5/#type-trimmed-channel-managers","title":"Type-Trimmed Channel Managers","text":"<p>In JDA v4, <code>GuildChannel#getManager</code> returned a <code>ChannelManager</code> that gave every possible setter for every channel type. This caused for <code>UnsupportedOperationException</code> or <code>IllegalStateException</code> to be thrown in some cases, such as calling <code>setBitrate</code> on a <code>TextChannel</code>.</p> <p>JDA v5 provides type-trimmed channel managers, which provide only the setters that we know for sure can work on the given channel. Each of these managers can be found in the <code>net.dv8tion.jda.api.managers.channel</code> package. These all follow the same implement/extension hierarchy as the channels do and map 1:1.</p>"},{"location":"introduction/migration-v4-v5/#independent-stage-channel-and-news-channel-entities","title":"Independent Stage Channel and News Channel Entities","text":"<p><code>StageChannel</code> and <code>NewsChannel</code> were previously variants of <code>VoiceChannel</code> and <code>TextChannel</code>. These are now their own independent entities. This comes with a number of changes:</p> <ul> <li><code>ChannelAction#setNews</code> is replaced by <code>ChannelAction.setType</code></li> <li><code>ChannelManager#getType</code> is replaced by <code>ChannelManager#getChannel()#getType</code></li> <li><code>ChannelManager#setNews</code> is replaced by <code>ChannelManager#setType</code></li> <li><code>TextChannel#crosspostMessage</code> is replaced by <code>NewsChannel#crosspostMessage</code></li> <li><code>TextChannel#follow</code> is replaced by <code>NewsChannel#follow</code></li> <li><code>TextChannel#isNews</code> was removed</li> </ul>"},{"location":"introduction/migration-v4-v5/#other-changes","title":"Other Changes","text":"<ul> <li><code>StoreChannel</code> was removed</li> <li><code>PrivateChannel#getUser</code> is now nullable</li> <li><code>MessageChannel#getLatestMessageId</code> and <code>MessageChannel#getLatestMessageIdLong</code> no longer change to null if the message was deleted</li> </ul>"},{"location":"introduction/migration-v4-v5/#permission-changes","title":"Permission Changes","text":"<p>A number of permissions have been renamed, with one permission being removed entirely.</p> <ul> <li><code>Permission.MANAGE_EMOTES</code> renamed to <code>Permission.MANAGE_EMOTES_AND_STICKERS</code></li> <li><code>Permission.MESSAGE_WRITE</code> renamed to <code>Permission.MESSAGE_SEND</code></li> <li><code>Permission.USE_SLASH_COMMANDS</code> renamed to <code>Permission.USE_APPLICATION_COMMANDS</code></li> <li><code>Permission.USE_PUBLIC_THREADS</code> renamed to <code>Permission.CREATE_PUBLIC_THREADS</code></li> <li><code>Permission.USE_PRIVATE_THREADS</code> renamed to <code>Permission.CREATE_PRIVATE_THREADS</code></li> <li><code>Permission.MESSAGE_READ</code> was removed in favor of <code>Permission.VIEW_CHANNEL</code></li> </ul>"},{"location":"introduction/migration-v4-v5/#event-changes","title":"Event Changes","text":"<p>There are several changes related to events.</p>"},{"location":"introduction/migration-v4-v5/#removal-of-guild-context-message-events","title":"Removal of Guild Context Message Events","text":"<p>All message event types for guild messages have been removed. Examples of these are:</p> <ul> <li><code>Generic&lt;Context&gt;MessageEvent</code> (ex: <code>GenericGuildMessageEvent</code>)</li> <li><code>&lt;Context&gt;MessageReceivedEvent</code> (ex: <code>GuildMessageReceivedEvent</code>)</li> <li><code>&lt;Context&gt;MessageUpdateEvent</code> (ex: <code>GuildMessageUpdateEvent</code>)</li> <li><code>&lt;Context&gt;MessageDeleteEvent</code> (ex: <code>GuildMessageDeleteEvent</code>)</li> <li><code>&lt;Context&gt;MessageEmbedEvent</code> (ex: <code>GuildMessageEmbedEvent</code>)</li> <li><code>&lt;Context&gt;MessageReaction&lt;X&gt;Event</code> (ex: <code>GuildMessageReactionAddEvent</code>)</li> </ul> <p>Instead, you should use the unified versions of these events:</p> <ul> <li><code>GenericMessageEvent</code></li> <li><code>MessageReceivedEvent</code></li> <li><code>MessageUpdatedEvent</code></li> <li><code>MessageDeletedEvent</code></li> <li><code>MessageReaction&lt;X&gt;Event</code> (ex: <code>MessageReactionAddEvent</code>)</li> </ul> <p>You can check if a message is from a <code>Guild</code> by using <code>Message#isFromGuild</code>.</p>"},{"location":"introduction/migration-v4-v5/#changes-to-specifying-gatewayintents-from-event-types","title":"Changes to Specifying GatewayIntents from Event Types","text":"<p>With context-specific events being removed (such as <code>GuildMessageReceivedEvent</code>), you can no longer use these events to specify <code>GatewayIntent.GUILD_MESSAGES</code> or <code>GatewayIntent.DIRECT_MESSAGE_REACTIONS</code>. You may supply any of the unified message events, but the functionality will be slightly different. It is not recommended to use <code>GatewayIntent#fromEvents</code> if you wish to have finer grain control around intents for messages.</p>"},{"location":"introduction/migration-v4-v5/#session-events","title":"Session Events","text":"<p>All events that update the gateway session of a bot now extend a common <code>GenericSessionEvent</code>. Such events are located within the <code>net.dv8tion.jda.api.events.session</code> package. This also includes <code>ReadyEvent</code> and <code>ShutdownEvent</code>.</p> <p>Some events relating to sessions have been renamed:</p> <ul> <li><code>DisconnectEvent</code> renamed to <code>SessionDisconnectEvent</code></li> <li><code>ReconnectedEvent</code> renamed to <code>SessionRecreateEvent</code></li> <li><code>ResumedEvent</code> renamed to <code>SessionResumeEvent</code></li> </ul>"},{"location":"introduction/migration-v4-v5/#voice-state-events","title":"Voice State Events","text":"<p><code>GuildVoiceJoinEvent</code> and <code>GuildVoiceLeaveEvent</code> have both been removed in favor of the unified <code>GuildVoiceUpdateEvent</code>.</p> <p>As an example, to detect when a user leaves a voice channel, you can use <code>GuildVoiceUpdateEvent#getChannelLeft</code>. This method will return the channel that the user left, or <code>null</code> if the user joined a channel instead.</p>"},{"location":"introduction/migration-v4-v5/#intent-and-member-cache-changes","title":"Intent and Member Cache Changes","text":"<p>A few changes to intents and member caching were also made to improve the user experience.</p>"},{"location":"introduction/migration-v4-v5/#renamed-intents","title":"Renamed Intents","text":"<p>The following intents have been renamed to align with the API name convention:</p> <ul> <li><code>GatewayIntent.GUILD_BANS</code> renamed to <code>GatewayIntent.GUILD_MODERATION</code></li> <li><code>GatewayIntent.GUILD_EMOJIS</code> renamed to <code>GatewayIntent.GUILD_EMOJIS_AND_STICKERS</code></li> </ul>"},{"location":"introduction/migration-v4-v5/#chunking-and-caching","title":"Chunking and Caching","text":"<p>If you used <code>ChunkingFilter.ALL</code> in the past, JDA would automatically also cache all those members it chunked. However, this is not a very flexible rule, and we changed this behavior. Instead, the <code>MemberCachePolicy</code> will control which members to keep cached after chunking.</p>"},{"location":"introduction/migration-v4-v5/#sticker-and-emoji-rework","title":"Sticker and Emoji Rework","text":"<p>We now fully support the sticker API in JDA. You can send up to 3 stickers in messages and receive both guild and nitro-only stickers. To improve the user experience with emotes/emoji we also changed this API.</p>"},{"location":"introduction/migration-v4-v5/#sticker-changes","title":"Sticker Changes","text":"<p>The old <code>MessageSticker</code> class has been removed in favor of an assortment of new interfaces located in <code>net.dv8tion.api.entities.sticker</code>. Instead, <code>Message#getStickers</code> now returns the new <code>StickerItem</code> interface. You can create a sendable sticker instance with <code>Sticker.fromId(stickerId)</code> and then pass it to <code>GuildMessageChannel#sendStickers</code>.</p>"},{"location":"introduction/migration-v4-v5/#emoteemoji-changes","title":"Emote/Emoji Changes","text":"<p>In old versions we always made a distinction between Emote and Emoji to differentiate Custom Emoji from Unicode Emoji. This naming scheme was not ideal and caused a bit of confusion. In our redesign we instead simplify this to the names <code>CustomEmoji</code> and <code>UnicodeEmoji</code>. Some classes/interfaces had to be renamed for this new design:</p> <ul> <li><code>Emote</code> renamed to <code>RichCustomEmoji</code></li> <li><code>EmoteManager</code> renamed to <code>CustomEmojiManager</code></li> <li><code>MessageReactionRemoveEmoteEvent</code> renamed to <code>MessageReactionRemoveEmojiEvent</code></li> </ul> <p>All methods/enums/types using <code>emote</code> have also been adjusted to say <code>emoji</code>, for example <code>Guild#retrieveEmotes</code> is now <code>Guild#retrieveEmojis</code> and <code>CacheFlag.EMOTE</code> is now <code>CacheFlag.EMOJI</code>.</p> <p>This new design also had the goal to unify all usages of emoji in the API, allowing you to use them for anything that makes use of emoji. For instance, previously there was a distinction between reaction emoji (<code>MessageReaction.ReactionEmote</code>) and button emoji (<code>Emoji</code>), which now both use the same <code>Emoji</code> type:</p> <pre><code>public void onMessageReactionAdd(MessageReactionAddEvent event) {\n  event.getChannel().sendMessage(\"User reacted\")\n    .setActionRow(Button.primary(\"buttonid\", event.getEmoji()))\n    .queue();\n}\n</code></pre> <p>To check which emoji was used in a reaction, you can use <code>emoji.equals(otherEmoji)</code> instead of checking for id/name. This has the advantage for also checking the correct type for you. For example: <code>event.getEmoji().equals(Emoji.fromFormatted(\"\ud83d\ude03\"))</code>.</p> <p>You also now use <code>Emoji</code> instances for reactions. What was previously <code>message.addReaction(\"...\")</code> is now <code>message.addReaction(Emoji.fromFormatted(\"...\"))</code>. And in general you can use the following factory methods to create emoji instances:</p> <ul> <li><code>Emoji.fromUnicode</code>     Parses codepoint notation like <code>\"U+1F602\"</code> or simply uses the provided unicode characters <code>\"\ud83d\ude03\"</code>. This returns a concrete <code>UnicodeEmoji</code> type instance.</li> <li><code>Emoji.fromCustom</code>     Creates a <code>CustomEmoji</code> instance from the provided name and id.</li> <li><code>Emoji.fromFormatted</code>     Parses emoji instances from markdown such as <code>\"&lt;:minn:12345581261712671&gt;\"</code> and also supports unicode such as <code>\"\ud83d\ude03\"</code> or codepoint notation <code>\"U+1F602\"</code>. This returns a <code>EmojiUnion</code> instance, which can be either custom or unicode.</li> </ul> <p>You can see the full list of breaking changes in #2117.</p>"},{"location":"introduction/migration-v4-v5/#message-sendedit-rework","title":"Message Send/Edit Rework","text":"<p>In JDA 5 we are separating the handling of message sending and editing, while also unifying all send and edit functionality in the API. The old <code>MessageBuilder</code> and <code>MessageAction</code> have been split up:</p> <ul> <li><code>MessageCreateBuilder</code></li> <li><code>MessageCreateAction</code></li> <li><code>MessageEditBuilder</code></li> <li><code>MessageEditAction</code></li> </ul> <p>This change should only affect people who made use of <code>MessageBuilder</code> in the past. You need to update your code to either the edit or create builders. If you don't know whether the resulting operation is an edit or send request, you can simply always use <code>MessageEditBuilder</code> and then use <code>MessageCreateData.fromEdit(MessageEditData)</code> to convert it at call-site. You can also use similar factory methods to create a sendable message from the <code>Message</code> interface (<code>MessageCreateData.fromMessage(message)</code>).</p> <p>Previously, edit requests had a method called <code>override(boolean)</code> to replace the entire message. This was used to remove content or embeds from a message. You can now simply use <code>setEmbeds(emptyList())</code> or <code>setContent(\"\")</code> to remove specific parts of the message, or use <code>setReplace(true)</code> to achieve the same functionality of replacing everything.</p>"},{"location":"introduction/migration-v4-v5/#method-renames","title":"Method Renames","text":"<p>Some methods were renamed to allow for consistency between all requests.</p> <ul> <li><code>setActionRows</code>/<code>addActionRows</code> renamed to <code>setComponents</code>/<code>addComponents</code></li> <li><code>MessageAction#tts</code> renamed to <code>MessageCreateRequest#setTTS</code></li> <li><code>MessageAction#content</code> renamed to <code>MessageCreateRequest#setContent</code></li> <li><code>MessageAction#allowedMentions</code> renamed to <code>MessageRequest#setAllowedMentions</code></li> <li><code>addFile</code> removed in favor of <code>addFiles</code> and <code>setAttachments</code> (see File Sending section below)</li> </ul>"},{"location":"introduction/migration-v4-v5/#unifying-message-requests","title":"Unifying Message Requests","text":"<p>All message send and edit requests now use a unified <code>MessageRequest</code> interface. This allows you to make very abstracted implementations that use high level interfaces.</p> <p></p> <p>This also means that all methods from <code>message.editMessage(...)</code> are consistent with the methods from <code>interaction.editMessage(...)</code>, and analogously for sending. You can now use <code>addActionRow</code> when sending a message to a channel.</p>"},{"location":"introduction/migration-v4-v5/#file-sending","title":"File Sending","text":"<p>The old <code>sendFile(...)</code>/<code>replyFile(...)</code> overloads available on <code>MessageChannel</code> and interactions has been replaced by a single <code>sendFiles(...)</code> method. This new method accepts the <code>FileUpload</code> type, which also supports file descriptions (alt text) via <code>setDescription(...)</code>. For example, old code such as <code>sendFile(data, name, AttachmentOption.SPOILER)</code> is replaced with <code>sendFiles(FileUpload.fromData(data, name).asSpoiler())</code>.</p> <p>Due to changes in the Discord API v10, you can no longer add files to messages without replacing all existing attachments. We could previously support methods such as <code>MessageAction#addFile</code> for editing messages, which is no longer possible in API v10. Instead, you must replace the entire list of attachments, using <code>MessageEditAction#setAttachments</code>. Here is an example:</p> <pre><code>// Here \"message\" is an instance of the Message interface\n\n// Take the first attachment of the message, all others will be removed\nAttachedFile attachment = message.getAttachments().get(0);\n\n// The name here will be \"cat.png\" to discord, what the file is called on your computer is irrelevant and only used to read the data of the image.\nFileUpload file = FileUpload.fromData(new File(\"mycat-final-copy.png\"), \"cat.png\"); // Opens the file called \"cat.png\" and provides the data used for sending\n\n// Edit request to keep the first attachment, and add one more file to the message\nmessage.editMessage(\"New content\")\n       .setAttachments(attachment, file)\n       .queue();\n</code></pre>"},{"location":"introduction/migration-v4-v5/#message-splitting","title":"Message Splitting","text":"<p>The old <code>MessageBuilder#buildAll</code> has been removed from the builder classes. Instead, you can now use the new <code>SplitUtil</code> utility class to split any string. For example:</p> <p>Old:</p> <pre><code>List&lt;Message&gt; messages = new MessageBuilder().setContent(someLargeString).buildAll();\n</code></pre> <p>New:</p> <pre><code>List&lt;String&gt; contents = SplitUtil.split(\n    someLargeString,  // input string of arbitrary length\n    2000,             // the split limit, can be arbitrary (&gt;0)\n    true,             // whether to trim the strings (empty will be discarded)\n    Strategy.NEWLINE, // split on '\\n' characters if possible\n    Strategy.ANYWHERE // otherwise split on the limit\n);\n// Convert to instance of MessageCreateData (optional, you can just send strings directly!)\nList&lt;MessageCreateData&gt; messages = contents.stream().map(MessageCreateData::fromContent).toList();\n</code></pre>"},{"location":"introduction/migration-v4-v5/#mentions-rework","title":"Mentions Rework","text":"<p>We made the handling of mentions consistent across both messages and interactions. You can now access mentions inside string options of slash commands through <code>OptionMapping#getMentions</code>. The old methods on <code>Message</code> have also been moved to a new <code>Mentions</code> interface, accessible via <code>Message#getMentions</code>.</p> <ul> <li><code>Message#getMentionedUsers</code> moved to <code>Mentions#getUsers</code></li> <li><code>Message#getMentionedMembers</code> moved to <code>Mentions#getMembers</code></li> <li><code>Message#getMentionedChannels</code> moved to <code>Mentions#getChannels</code></li> <li><code>Message#getEmotes</code> moved to <code>Mentions#getCustomEmojis</code></li> <li><code>Message#getMentions(MentionType...)</code> moved to <code>Mentions#getMentions(MentionType...)</code></li> <li><code>Message#isMentioned</code> moved to <code>Mentions#isMentioned</code></li> <li><code>Message#getMentionedMembers(Guild)</code> has been removed with no replacement</li> <li><code>Message#mentionsEveryone</code> moved to <code>Mentions#mentionsEveryone</code></li> <li>Analogously for all bag getters.</li> </ul> <p>Additionally, the return type of <code>Mentions#getChannels</code> has been adjusted to return <code>List&lt;GuildChannel&gt;</code> since all channel types can now be mentioned. You can use <code>Mentions#getChannels(Class)</code> to limit it to specific types, for example <code>List&lt;TextChannel&gt; channels = mentions.getChannels(TextChannel.class)</code>.</p>"},{"location":"introduction/migration-v4-v5/#interaction-rework","title":"Interaction Rework","text":"<p>To properly handle Context Menu and Auto-complete interactions, we reworked some interaction types. This includes numerous breaking changes to naming conventions and package layouts.</p>"},{"location":"introduction/migration-v4-v5/#naming-changes","title":"Naming Changes","text":"<ul> <li><code>SlashCommandEvent</code> renamed to <code>SlashCommandInteractionEvent</code></li> <li><code>ButtonClickEvent</code> renamed to <code>ButtonInteractionEvent</code></li> <li><code>SelectionMenu</code> renamed to <code>StringSelectMenu</code></li> <li><code>SelectionMenuEvent</code> renamed to <code>StringSelectEvent</code></li> <li><code>Component</code> renamed to <code>ActionComponent</code> and <code>ItemComponent</code> (abstraction for things like <code>Button</code>)</li> <li><code>ComponentLayout</code> renamed to <code>LayoutComponent</code> (abstraction for things like <code>ActionRow</code>)</li> <li>Introduced new <code>Component</code> interface to abstract both layouts and items.</li> <li><code>MessageType.APPLICATION_COMMAND</code> renamed to <code>MessageType.SLASH_COMMAND</code> (we now also have <code>MessageType.CONTEXT_COMMAND</code>)</li> <li><code>InteractionType.SLASH_COMMAND</code> renamed to <code>InteractionType.COMMAND</code> (we now also have <code>InteractionType.COMMAND_AUTOCOMPLETE</code>)</li> <li><code>SlashCommandEvent#getCommandPath</code> renamed to <code>CommandInteractionPayload#getFullCommandName</code> (it also now uses spaces instead of slashes, e.g. <code>mod/ban</code> is now <code>mod ban</code>)</li> </ul>"},{"location":"introduction/migration-v4-v5/#creating-and-handling-commands","title":"Creating and Handling Commands","text":"<p>With the introduction of Context Menu Commands, we changed how commands are created. Instead of <code>new CommandData(...)</code>, you now create a slash command using the factory method <code>Commands.slash(...)</code>, which returns a <code>SlashCommandData</code> instance that has the familiar methods. You can now also use <code>Commands.user(...)</code> and <code>Commands.message(...)</code> to create new context menu commands which appear in the right-click menu option named Apps in the Discord Client.</p> <p>Handling commands only changed slightly with regard to the way you reply. Previously, all <code>Interaction</code> types had a <code>reply(...)</code> or <code>deferReply(...)</code> method. This has been changed due to new interaction types like AutoCompleteInteraction and ModalInteraction. Now, each concrete interaction type implements specific callback interfaces such as:</p> <ul> <li><code>IReplyCallback</code>     Which supports direct message replies and deferred message replies via <code>reply(String)</code> and <code>deferReply()</code></li> <li><code>IMessageEditCallback</code>     Which supports direct message edits and deferred message edits (or no-operation) via <code>editMessage(String)</code> and <code>deferEdit()</code></li> <li><code>IModalCallback</code>     Which supports replying using a Modal via <code>replyModal(Modal)</code></li> <li><code>IAutoCompleteCallback</code>     Which supports choice suggestions for auto-complete interactions via <code>replyChoices(Command.Choice...)</code></li> </ul> <p>If you relied on the abstract <code>Interaction</code> type to provide any of these methods, you will have to adjust your code to use these new interfaces instead.</p> <p>You can find more explanations and examples in the dedicated Interactions Wiki Page.</p>"},{"location":"introduction/migration-v4-v5/#command-permissionsprivileges","title":"Command Permissions/Privileges","text":"<p>Discord has changed how command permissions work. Instead of limiting commands to specific roles and users on a per-guild basis, you set required permissions on each command. For instance, a ban command would require <code>Permission.BAN_MEMBERS</code>:</p> <pre><code>commands.addCommands(\n    Commands.slash(\"ban\", \"Ban a user from this server. Requires permission to ban users.\")\n        .addOption(USER, \"user\", \"The user to ban\", true)\n        .addOptions(new OptionData(INTEGER, \"del_days\", \"Delete messages from the past days.\")\n            .setRequiredRange(0, 7)) // Only allow values between 0 and 7 (inclusive)\n        .addOptions(new OptionData(STRING, \"reason\", \"The ban reason to use (default: Banned by &lt;user&gt;)\"))\n        // This way the command can only be executed from a guild, and not DMs\n        .setGuildOnly(true)\n        // Only members with the BAN_MEMBERS permission are going to see this command\n        .setDefaultPermissions(DefaultMemberPermissions.enabledFor(Permission.BAN_MEMBERS))\n)\n</code></pre> <p>You can also limit it to administrators with <code>DefaultMemberPermissions.DISABLED</code>.</p>"},{"location":"introduction/migration-v4-v5/#usersnowflake-type","title":"UserSnowflake Type","text":"<p>We have started to cut down on overloads which accept 3 different inputs to specify a user. Previously methods like <code>Guild#ban</code> had many overloads to account for different types such as <code>String</code>/<code>long</code>/<code>User</code>/<code>Member</code>. We removed all of these in favor of a single <code>UserSnowflake</code> input, which can be constructed with <code>User.fromId(long/String)</code>. Both <code>User</code> and <code>Member</code> also implement this interface. This is a far more elegant handling and reduces the number of overloads in various parts of the API drastically.</p> <p>This applies to the following methods:</p> <ul> <li><code>Guild#ban(long/String)</code>, <code>Guild#ban(long/String, int)</code>, <code>Guild#ban(long/String, int, String)</code>     Now just <code>Guild#ban(UserSnowflake, int, TimeUnit)</code></li> <li><code>Guild#kick(long/String)</code>, <code>Guild#kick(long/String, String)</code>     Now just <code>Guild#kick(UserSnowflake)</code></li> <li><code>Guild#unban(long/String)</code> is now <code>Guild#unban(UserSnowflake)</code></li> <li><code>Guild#retrieveBanById(long/String)</code> is now <code>Guild#retrieveBan(UserSnowflake)</code></li> <li><code>Guild#addMember(String, long/String)</code> is now <code>Guild#addMember(UserSnowflake)</code></li> <li><code>Guild#timeoutForById(long/String, Duration)</code> is now <code>Guild#timeoutFor(UserSnowflake, Duration)</code></li> <li><code>Guild#timeoutUntilById(long/String, TemporalAccessor)</code> is now <code>Guild#timeoutUntil(UserSnowflake, TemporalAccessor)</code></li> <li><code>Guild#removeTimeoutById(long/String)</code> is now <code>Guild#removeTimeout(UserSnowflake)</code></li> <li><code>Guild#addRoleToMember(long/String, Role)</code> is now <code>Guild#addRoleToMember(UserSnowflake)</code></li> <li><code>Guild#removeRoleFromMember(long/String, Role)</code> is now <code>Guild#removeRoleFromMember(UserSnowflake)</code></li> <li><code>AuditLogPaginationAction#user(long/String)</code> is now <code>AuditLogPaginationAction#user(UserSnowflake)</code></li> </ul>"},{"location":"introduction/migration-v4-v5/#ban-precision","title":"Ban Precision","text":"<p>You can now specify the age of messages to delete in seconds precision. To adjust your code simply add <code>TimeUnit.DAYS</code> to the end and move the ban reason into the <code>reason(...)</code> method:</p> <p>Old:</p> <pre><code>guild.ban(user, 7, \"Naughty words\").queue()\n</code></pre> <p>New:</p> <pre><code>guild.ban(user, 7, TimeUnit.DAYS).reason(\"Naughty words\").queue()\n</code></pre> <p>Kick reasons have also been moved into the <code>reason(...)</code> method, for example <code>guild.kick(user, reason)</code> turns into <code>guild.kick(user).reason(reason)</code>.</p>"},{"location":"introduction/migration-v4-v5/#managers-are-no-longer-persistent","title":"Managers are no longer persistent","text":"<p>All getters for managers in JDA used to be lazy-idempotent, such that calling <code>getManager()</code> twice would return the same instance. This has been removed to reduce memory usage and complexity. If you previously relied on this behavior, you will need to adjust your code.</p> <p>Old:</p> <pre><code>channel.getManager().setName(\"new-name\");\nchannel.getManager().setTitle(\"here is my title\");\nchannel.getManager().queue();\n</code></pre> <p>New:</p> <pre><code>// Use method chaining or declare a variable to re-use the manager\nchannel.getManager()\n       .setName(\"new-name\")\n       .setTitle(\"here is my title\")\n       .queue();\n</code></pre>"},{"location":"setup/eclipse/","title":"Eclipse Setup","text":"Gradle SetupMaven SetupJar Setup <ol> <li> <p>If you have Eclipse IDE for Java Developers installed, skip to 2., otherwise you need to install the Buildship Gradle Integration plugin first:</p> <ol> <li>Open up Eclipse and go to the Marketplace (located under the Help tab)</li> <li>Search for \"Gradle\" and install Buildship Gradle Integration (Plugin-Page)</li> <li>After the plugin is installed, relaunch Eclipse</li> </ol> </li> <li> <p>Right click within Package/Project Explorer and select New &gt; Other...</p> <p></p> </li> <li> <p>In the Gradle folder, select Gradle Project</p> <p></p> </li> <li> <p>Type a name for your Project and click on Finish. Your setup should look like this at this point:</p> <p></p> </li> <li> <p>Delete the classes within <code>src/main/java</code> and <code>src/test/java</code></p> <p></p> </li> <li> <p>Open up and edit the file <code>build.gradle</code></p> <p></p> </li> <li> <p>Replace its content with the following code:</p> <pre><code>plugins {\n    id(\"java\")\n    id(\"application\")\n    id(\"com.gradleup.shadow\") version \"8.3.1\"\n}\n\nmainClassName = \"com.example.jda.Bot\"\n\nversion '1.0'\n\nsourceCompatibility = 1.8\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"net.dv8tion:JDA:#.#.#\")\n}\n\ncompileJava.options.encoding = \"UTF-8\"\n</code></pre> </li> <li> <p>Adjust the version of JDA you want to use (see dependencies-section of file) and fill in your Main-Class as soon as you have one (the one containing your <code>public static void main(String[] args)</code> method)</p> </li> <li> <p>Save the file and do the following: Right click your project &gt; Gradle &gt; Refresh All</p> <p></p> </li> <li> <p>Once all the dependencies have been downloaded, create your desired packages/classes in <code>src/main/java</code> and start coding!</p> </li> <li>To build your project you can run <code>gradlew shadowJar</code> in a terminal of your project root, and it will produce a jar filled with your compiled code and JDA included in a single jar file! The jar can be found in <code>build/libs</code></li> <li>Setup Logback</li> <li>Continue with Getting Started</li> </ol> <p>Prerequisites: Maven-Plugin and local Maven installation</p> <ol> <li> <p>Create a new Maven project. (File -&gt; New -&gt; Other -&gt; Maven -&gt; Maven Project)</p> <p></p> </li> <li> <p>Check the <code>Create a simple project</code> box on the next page as we don't need to worry about archetypes.</p> <p></p> </li> <li> <p>Add a groupId, artifactId and a name. Make sure you try to follow the naming conventions while you are at this step. The result could look like the image below.</p> <p></p> </li> <li> <p>Now let's start configuring it, first off, open up your pom.xml and add the following lines right after <code>&lt;/description&gt;</code> <pre><code>&lt;properties&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n&lt;/properties&gt;\n</code></pre></p> </li> <li> <p>This will make your project support UTF-8 characters (So you can have it on Japanese servers for example) and also force Java 8, which is needed.</p> </li> <li> <p>Now, add the dependency, make sure you change <code>X.Y.Z</code> to the latest version number (You can find it in the releases: https://github.com/discord-jda/JDA/releases)     <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n    &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n    &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n    &lt;version&gt;X.Y.Z&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre></p> </li> <li> <p>Now you need to set up the (build) maven-shade and maven-compile plugins, add the following lines right after <code>&lt;/dependencies&gt;</code></p> <p>Note</p> <p>The following changes will force the compiler to use Java 8 (JDA needs it), so make sure you have it installed.</p> <pre><code>&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.8.1&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;source&gt;1.8&lt;/source&gt;\n                &lt;target&gt;1.8&lt;/target&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n        &lt;plugin&gt;\n            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;\n            &lt;version&gt;3.2.4&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;transformers&gt;\n                    &lt;transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\"&gt;\n                        &lt;mainClass&gt;YourMainClass&lt;/mainClass&gt; &lt;!-- (1) --&gt;\n                    &lt;/transformer&gt;\n                &lt;/transformers&gt;\n                &lt;createDependencyReducedPom&gt;false&lt;/createDependencyReducedPom&gt;\n            &lt;/configuration&gt;\n            &lt;executions&gt;\n                &lt;execution&gt;\n                    &lt;phase&gt;package&lt;/phase&gt;\n                    &lt;goals&gt;\n                        &lt;goal&gt;shade&lt;/goal&gt;\n                    &lt;/goals&gt;\n                &lt;/execution&gt;\n            &lt;/executions&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <ol> <li>You have to replace this with a path to your main class like <code>me.myname.mybotproject.Main</code></li> </ol> </li> <li> <p>After that, the project must be updated to download the dependencies. Right click &gt; Maven &gt; Update Project</p> <p> </p> </li> <li> <p>You are done! Now you can head to the Javadocs or see examples at the Examples page.</p> </li> <li>Setup Logback</li> <li>Continue with Getting Started</li> </ol> <ol> <li>Download the latest (Binary) version of JDA (with Dependencies):<ul> <li>https://github.com/discord-jda/JDA/releases/</li> </ul> </li> <li> <p>Create a new Java Project</p> <p></p> </li> <li> <p>Fill out the bot name, and set it to Java 8 (or above if available). This option might be set automatically when the <code>Use default location</code> box is checked.</p> <p></p> </li> <li> <p>Right click the project, go to Properties</p> </li> <li> <p>Click on Java Build Path, then click on Libraries, then on Classpath, Add External JARs...</p> <p></p> </li> <li> <p>Add your downloaded JDA-withDependencies-x.x.x.jar and expand its properties</p> </li> <li> <p>If you don't want Javadoc and source annotations, skip to 11 (not recommended).</p> <p></p> </li> <li> <p>Click on Source Attachment, then on Edit..., then mark External Locations and click on External File</p> <p></p> </li> <li> <p>Here, add your JDA-x.x.x_xxx-sources.jar and click on OK</p> </li> <li> <p>Next, click on Javadoc Location, then on Edit..., then mark Javadoc in archive and click on Browse</p> <p></p> </li> <li> <p>Here, add your JDA-x.y.z-www.p-javadoc.jar and click on OK</p> </li> <li>Setup Logback</li> <li>Continue with Getting Started</li> </ol>"},{"location":"setup/intellij/","title":"IntelliJ IDEA Setup","text":"New UI of IntelliJ IDEAOlder UI of IntelliJ IDEA <ol> <li>Navigate to \"New Project\" from any view</li> <li> <p>Select Gradle -&gt; Java as the type of Project and make sure the correct JDK is selected (Java 8 or higher)</p> <p></p> </li> <li> <p>Let IntelliJ index your project.</p> </li> <li> <p>Open <code>build.gradle.kts</code></p> </li> <li> <p>Populate the build file with the following     <pre><code>plugins {\n    application\n    id(\"com.gradleup.shadow\") version \"8.3.1\"\n}\n\napplication.mainClass = \"com.example.discordbot.Bot\" // (1)\ngroup = \"org.example\"\nversion = \"1.0\"\n\nval jdaVersion = \"JDA_VERSION_HERE\" // (2)\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"net.dv8tion:JDA:$jdaVersion\")\n}\n\ntasks.withType&lt;JavaCompile&gt; {\n    options.encoding = \"UTF-8\"\n    options.isIncremental = true\n\n    // Set this to the version of java you want to use,\n    // the minimum required for JDA is 1.8\n    sourceCompatibility = \"1.8\"\n}\n</code></pre></p> <ol> <li> <p>Replace the <code>mainClass</code> value with the path to your main class later on! </p> </li> <li> <p>Replace the <code>JDA_VERSION_HERE</code> with the one mentioned in the latest release</p> </li> </ol> </li> <li> <p>Reload Gradle and wait for it to finish</p> <p></p> </li> <li> <p>If IntelliJ IDEA didn't already do so automatically, set up a source folder as <code>src/main/java</code></p> </li> <li>Create your group package. Example: <code>com.example.discordbot</code></li> <li>Make your main class. Example: <code>Bot.java</code>.     Your directory tree should look like this:     <pre><code>ProjectName -&gt; src/main/java -&gt; com/example/discordbot -&gt; Bot.java\n            -&gt; gradle/wrapper -&gt; gradle-wrapper.properties\n            -&gt; gradle/wrapper -&gt; gradle-wrapper.jar\n            -&gt; build.gradle.kts\n            -&gt; settings.gradle.kts\n</code></pre></li> <li>Configure the <code>mainClass</code> value in the <code>build.gradle.kts</code> to your class. Example: <code>com.example.discordbot.Bot</code></li> <li> <p>To build your finished project simply use the <code>shadowJar</code> task in your Gradle tool window on right hand side of your editor.     &gt; You can also run your project with the <code>run</code> Gradle task!</p> <p></p> </li> <li> <p>This will build a jar in <code>build/libs</code>. The one with the <code>-all</code> suffix is the shadow jar.</p> <p></p> </li> <li> <p>Setup Logback</p> </li> <li>Continue with Getting Started</li> </ol> <ol> <li>Navigate to \"New Project\" from any view</li> <li> <p>Select Gradle -&gt; Java as the type of Project and make sure the correct JDK is selected (Java 8 or higher)</p> <p></p> </li> <li> <p>Let IntelliJ index your project.</p> <p></p> </li> <li> <p>Open <code>build.gradle.kts</code></p> </li> <li> <p>Populate the build file with the following     <pre><code>plugins {\n    application\n    id(\"com.gradleup.shadow\") version \"8.3.1\"\n}\n\napplication.mainClass = \"com.example.discordbot.Bot\" // (1)\ngroup = \"org.example\"\nversion = \"1.0\"\n\nval jdaVersion = \"JDA_VERSION_HERE\" // (2)\n\nrepositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"net.dv8tion:JDA:$jdaVersion\")\n}\n\ntasks.withType&lt;JavaCompile&gt; {\n    options.encoding = \"UTF-8\"\n    options.isIncremental = true\n\n    // Set this to the version of java you want to use,\n    // the minimum required for JDA is 1.8\n    sourceCompatibility = \"1.8\"\n}\n</code></pre></p> <ol> <li> <p>Replace the <code>mainClass</code> value with the path to your main class later on! </p> </li> <li> <p>Replace the <code>JDA_VERSION_HERE</code> with the one mentioned in the latest release</p> </li> </ol> </li> <li> <p>Reload Gradle and wait for it to finish</p> <p></p> </li> <li> <p>If IntelliJ IDEA didn't already do so automatically, set up a source folder as <code>src/main/java</code></p> </li> <li>Create your group package. Example: <code>com.example.discordbot</code></li> <li>Make your main class. Example: <code>Bot.java</code>.     Your directory tree should look like this:     <pre><code>ProjectName -&gt; src/main/java -&gt; com/example/discordbot -&gt; Bot.java\n            -&gt; gradle/wrapper -&gt; gradle-wrapper.properties\n            -&gt; gradle/wrapper -&gt; gradle-wrapper.jar\n            -&gt; build.gradle.kts\n            -&gt; settings.gradle.kts\n</code></pre></li> <li>Configure the <code>mainClass</code> value in the <code>build.gradle.kts</code> to your class. Example: <code>com.example.discordbot.Bot</code></li> <li> <p>To build your finished project simply use the <code>shadowJar</code> task in your Gradle tool window on right hand side of your editor.     &gt; You can also run your project with the <code>run</code> Gradle task!</p> <p></p> </li> <li> <p>This will build a jar in <code>build/libs</code>. The one with the <code>-all</code> suffix is the shadow jar.</p> <p></p> </li> <li> <p>Setup Logback</p> </li> <li>Continue with Getting Started</li> </ol>"},{"location":"setup/logging/","title":"Logging (SLF4J)","text":"<p>When you setup a JDA project you should also setup a logging implementation for SLF4J. This is only necessary if you get a warning like this on startup:</p> <pre><code>SLF4J(W): No SLF4J providers were found.\nSLF4J(W): Defaulting to no-operation (NOP) logger implementation\nSLF4J(W): See https://www.slf4j.org/codes.html#noProviders for further details.\n</code></pre> <p>I recommend logback-classic as it is my goto implementation. First add logback to your dependencies:</p> GradleMaven <pre><code>dependencies {\n    implementation(\"ch.qos.logback:logback-classic:1.5.6\")\n}\n</code></pre> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n    &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n    &lt;version&gt;1.5.6&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Info</p> <p>The minimum required java version for logback-classic is Java 11 since 1.4.0. To use logback with Java 8, you can use the latest 1.3.x release instead. See logback news for details.</p>"},{"location":"setup/logging/#configure-logback","title":"Configure Logback","text":"<p>The logback configuration needs to be in your resources directory. This is <code>src/main/resources</code> in all standard Gradle and Maven projects. Add the following configuration into <code>src/main/resources/logback.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;configuration&gt;\n    &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;%d{HH:mm:ss.SSS} %boldCyan(%-34.-34thread) %red(%10.10X{jda.shard}) %boldGreen(%-15.-15logger{0}) %highlight(%-6level) %msg%n&lt;/pattern&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=\"info\"&gt;\n        &lt;appender-ref ref=\"STDOUT\" /&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre> <p>You can read up on how this configuration works in the logback manual.</p>"},{"location":"setup/logging/#how-to-enable-debug-logs","title":"How to enable debug logs","text":"<p>In the config above, change the level for the root logger to debug:</p> <pre><code>&lt;root level=\"debug\"&gt;\n  ...\n&lt;/root&gt;\n</code></pre>"},{"location":"setup/logging/#supported-mdc-options","title":"Supported MDC Options","text":"<p>There are a few built-in MDC options used by JDA:</p> <ul> <li><code>jda.shard</code> The shard id and shard total in the format <code>[id / total]</code>. (This is 0-based so with a total of 10 the last shard id <code>[9 / 10]</code>)</li> <li><code>jda.shard.id</code> The shard id</li> <li><code>jda.shard.total</code> The shard total</li> </ul> <p>You can further configure other MDC variables for JDA threads with JDABuilder.setContextMap!</p>"},{"location":"setup/netbeans/","title":"Netbeans Setup","text":"Maven SetupJar Setup <ol> <li> <p>Make a new Maven Java Application</p> <p></p> </li> <li> <p>Open up the pom.xml in the Project Files</p> <p></p> </li> <li> <p>Add JDA as a dependency</p> <p>Note</p> <p>These can go anywhere within the <code>&lt;project&gt;&lt;/project&gt;</code> tags.</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;net.dv8tion&lt;/groupId&gt;\n        &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n        &lt;version&gt;5.x.y&lt;/version&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> </li> <li> <p>Setup Logback</p> </li> <li> <p>Continue with Getting Started</p> </li> </ol> <ol> <li> <p>Download the latest (binary) version of JDA (with dependencies), as well as the javadocs</p> <ul> <li>https://github.com/discord-jda/JDA/releases/latest</li> </ul> <p></p> </li> <li> <p>Make a new Java Application</p> <p></p> </li> <li> <p>Right-click the <code>Libraries</code> folder in your project, and select <code>Add JAR/Folder...</code></p> <p></p> </li> <li> <p>Find the <code>JDA...withDependencies.jar</code> and add it.</p> </li> <li> <p>Right-click on the newly-added Jar file, and select <code>Edit...</code></p> <p></p> </li> <li> <p>Select <code>Browse...</code> and add the javadoc jar</p> <p></p> </li> <li> <p>Setup Logback</p> </li> <li>Continue with Getting Started</li> </ol>"},{"location":"using-jda/gateway-intents-and-member-cache-policy/","title":"Gateway Intents","text":"<p>In version 4.2.0, we introduced the <code>GatewayIntent</code> enum. This marks a change in the way bots will work in the future.</p> <p>Building JDA is done using one of the JDABuilder factory methods, each of which has some default intents:</p> <ul> <li><code>createDefault</code></li> <li><code>createLight</code></li> <li><code>create</code></li> </ul>"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#what-intents-do-i-need","title":"What Intents do I need?","text":"<p>The necessary intents directly correlate with the features you intend to use. Each <code>GatewayIntent</code> documents which events are enabled by it. Some caches in JDA also depend on these intents, so take a close look at the documentation for <code>CacheFlag</code> as well.</p> <p>For instance, a bot that only responds to messages and sends welcome messages will only need <code>GUILD_MESSAGES</code>, <code>MESSAGE_CONTENT</code>, and <code>GUILD_MEMBERS</code>. A bot like this doesn't rely on any members being cached, so the right solution is to use <code>createLight</code> which will disable all <code>CacheFlags</code> and member caching.</p> <pre><code>public static void main(String[] args) {\n  // createLight disables unused cache flags\n  // GUILD_MESSAGES enables events for messages sent in guilds\n  // MESSAGE_CONTENT enables access to the content of messages sent by other users\n  // GUILD_MEMBERS gives you access to guild member join events so you can send welcome messages\n  // The resulting JDA instance will not cache any members since createLight disables it.\n  JDABuilder.createLight(BOT_TOKEN, GatewayIntent.GUILD_MESSAGES, GatewayIntent.MESSAGE_CONTENT, GatewayIntent.GUILD_MEMBERS)\n            .addEventListeners(new JoinListener())\n            .addEventListeners(new CommandHandler())\n            .build();\n}\n</code></pre> <p>Due to <code>GUILD_MEMBERS</code> and <code>MESSAGE_CONTENT</code> being a privileged intents, you must also enable it in your developer dashboard:</p> <ol> <li>Open the application dashboard</li> <li>Select your bot application</li> <li>Open the Bot tab</li> <li>Under the Privileged Gateway Intents section, enable SERVER MEMBERS INTENT and MESSAGE CONTENT INTENT.</li> </ol> <p>If you use these intents, you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent, you have to verify your bot. This will be available in your application dashboard when the bot joins at least 76 guilds.</p> <p>You can also choose to just use <code>createLight</code> or <code>createDefault</code> without specifying the intents you need. In that case, JDA will just use GatewayIntent.DEFAULT. If you want to use the default but also include some additional intents like <code>GUILD_MEMBERS</code> then you can use <code>enableIntents</code>:</p> <pre><code>JDABuilder.createDefault(token) // enable all default intents\n          .enableIntents(GatewayIntent.GUILD_MEMBERS) // also enable privileged intent\n          .addEventListeners(new JoinListener())\n          .addEventListeners(new CommandHandler())\n          .build();\n</code></pre>"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>I'm getting CloseCode(4014 / Disallowed intents...)</li> <li>My event listener code is not executed</li> <li>Cannot get message content / Attempting to access message content without GatewayIntent</li> </ul>"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#cacheflags","title":"CacheFlags","text":"<p>JDA provides a number of different optional caches you can enable or disable. Most of these caches are configured using the <code>CacheFlag</code> enum.</p> <p>You can manually enable or disable these caches by using <code>enableCache</code> and <code>disableCache</code> respectively.</p> <p>Each <code>createX</code> factory method on the JDABuilder also configures a set of enabled flags automatically, based on your choice of intents. The <code>CacheFlag</code> enum documents which intents are required to use it and JDA will automatically disable them if the required intent is missing.</p> <p>If a flag is automatically disabled due to a missing intent, we print a warning telling you it was disabled and which intent was missing. To remove this warning, you have to explicitly disable the <code>CacheFlag</code> by using <code>disableCache</code> or, if you need the cache, enable the intent using <code>enableIntents</code>.</p> <p>The individual factory methods document which defaults will be used:</p> <ol> <li><code>createDefault</code></li> <li><code>createLight</code></li> <li><code>create</code></li> </ol>"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#membercachepolicy","title":"MemberCachePolicy","text":"<p>Together with intents, Discord now wants to further restrict data access for bots by limiting how many members they can cache. To properly maintain a cache of all members, you need the <code>GUILD_MEMBERS</code> intent, because it will enable the <code>GuildMemberRemoveEvent</code> to remove members from cache once they leave the guild. Without this intent, JDA would infinitely grow its cache without knowing when to remove members.</p> <p>To handle this new default, we now have a <code>MemberCachePolicy</code> which can be configured using <code>setMemberCachePolicy</code>. Each factory method will set a default cache policy which will only retain members under certain conditions:</p> <ul> <li><code>createLight</code> Will only cache the self member</li> <li><code>createDefault</code> Will only cache members who are connected to a voice channel, the guild owner, and the self member</li> <li><code>create</code> Will cache all members it can properly track. See the docs for further details.</li> </ul> <p>We also provide a few reasonable implementations to choose from and apply using <code>setMemberCachePolicy</code>:</p> <ul> <li>All     Will keep all members cached (requires <code>GUILD_MEMBERS</code> intents)</li> <li>Online     Will keep all online members cached (requires <code>GUILD_PRESENCES</code> intent)</li> <li>Voice     Will keep all voice members cached (requires <code>GUILD_VOICE_STATES</code> intent)</li> <li>Owner     Will keep the guild owner cached</li> <li>Pending     Will cache the members which have not passed membership screening yet (requires <code>GUILD_MEMBERS</code> intents)</li> <li>None     Will only keep the self member cached and nobody else</li> </ul> <p>It is important to understand the difference between cache and load in this system.</p> <pre><code>JDABuilder.createDefault(token)\n          .enableIntents(GatewayIntent.GUILD_MEMBERS)\n          .setMemberCachePolicy(MemberCachePolicy.ALL)\n          .build();\n</code></pre> <p>The difference becomes clear when you try to access the member list using this configuration. The <code>MemberCachePolicy.ALL</code> will specifically cache all members once they are loaded. However, we are lazy loading members and start off with only a small subset of all members in cache. This cache will grow over time by loading members when they are active in the guilds, such as sending a message or connecting to a voice channel.</p>"},{"location":"using-jda/gateway-intents-and-member-cache-policy/#loading-members","title":"Loading Members","text":"<p>We offer a number of ways to load and cache members:</p> <ul> <li>Guild.retrieveMembersByPrefix(String, int)</li> <li>Guild.retrieveOwner()</li> <li>Guild.retrieveMemberById(long|String)</li> <li>Guild.retrieveMembersByIds(long...|String..)</li> <li>Guild.retrieveMembers(Collection&lt;User&gt;)</li> <li>Message.getMember() (from events)</li> </ul> <p>All of these methods will load the members from cache or fallback to requesting them from the Discord API.</p> <p>You can also load the entire member list at runtime by using <code>loadMembers</code>, however this requires the privileged <code>GUILD_MEMBERS</code> intent. This process is called guild member chunking (aka chunking).</p> <p>Chunking can also be performed for many guilds at startup automatically, by using <code>setChunkingFilter</code> on the JDABuilder.  This also requires the <code>GUILD_MEMBERS</code> intent</p>"},{"location":"using-jda/getting-started/","title":"Making a Ping-Pong Bot","text":""},{"location":"using-jda/getting-started/#creating-a-discord-bot","title":"Creating a Discord Bot","text":"<ol> <li>Go to https://discord.com/developers/applications</li> <li>Create an Application</li> <li> <p>Give the application an awesome name (this will be used as the bots initial username)</p> <p></p> </li> <li> <p>Click Save Changes</p> </li> <li> <p>Open the Bot tab</p> <p></p> </li> <li> <p>Make sure to make your bot public, this allows others to invite your bot to your server.</p> <p></p> <p>You only want require code grant enabled if you plan to use an oauth2 flow, the general user will not need this.</p> </li> </ol>"},{"location":"using-jda/getting-started/#add-your-discord-bot-to-a-server","title":"Add your Discord Bot to a Server","text":"<ol> <li> <p>Retrieve your application/client ID from the General Information tab</p> <p></p> </li> <li> <p>Create an OAuth2 authorization URL (reference docs).     Users who want to use Interaction Commands should also add the <code>applications.commands</code> scope.     Some example URLs:</p> <ul> <li><code>https://discord.com/api/oauth2/authorize?client_id=492747769036013578&amp;scope=bot</code></li> <li><code>https://discord.com/api/oauth2/authorize?client_id=492747769036013578&amp;scope=bot+applications.commands</code></li> </ul> <p>Note</p> <p>This can be done from the Bot tab at the very bottom. Here you can select the scope bot and some permissions required for your bots functionality (optional).</p> </li> <li> <p>Open the authorization dialogue (click link from step 2)</p> </li> <li>Select your Server (Requires permission to manage server)</li> <li> <p>Click Authorize</p> <p></p> </li> </ol>"},{"location":"using-jda/getting-started/#connecting-to-discord-with-a-bot-account","title":"Connecting to Discord with a Bot Account","text":"<ol> <li> <p>Retrieve your Bot Token from your application dashboard (https://discord.com/developers/applications)</p> <p></p> <p>Caution</p> <p>Note that it is very important not to show this token to anyone, ever.</p> </li> <li> <p>Set up your JDA project: </p> <ul> <li>IntelliJ IDEA</li> <li>Eclipse</li> <li>Netbeans</li> </ul> <p> </p> </li> <li> <p>Create <code>JDABuilder</code> instance with token</p> </li> <li> <p>Build JDA using <code>JDABuilder.build()</code></p> <pre><code>public static void main(String[] arguments) throws Exception\n{\n    JDA api = JDABuilder.createDefault(BOT_TOKEN).build();\n}\n</code></pre> <p>Tip</p> <p>It is often better to load your token in from an external file or environment variable, especially if you plan on publishing the source code.</p> </li> </ol>"},{"location":"using-jda/getting-started/#making-a-ping-pong-protocol","title":"Making a Ping-Pong Protocol","text":"<ol> <li>Setup your JDA instance (see Connecting To Discord)</li> <li> <p>Implement an <code>EventListener</code> or extend <code>ListenerAdapter</code></p> <pre><code>public class MyListener extends ListenerAdapter \n{\n    @Override\n    public void onMessageReceived(MessageReceivedEvent event)\n    {\n        if (event.getAuthor().isBot()) return;\n        // We don't want to respond to other bot accounts, including ourself\n        Message message = event.getMessage();\n        String content = message.getContentRaw(); \n        // getContentRaw() is an atomic getter\n        // getContentDisplay() is a lazy getter which modifies the content for e.g. console view (strip discord formatting)\n        if (content.equals(\"!ping\"))\n        {\n            MessageChannel channel = event.getChannel();\n            channel.sendMessage(\"Pong!\").queue(); // Important to call .queue() on the RestAction returned by sendMessage(...)\n        }\n    }\n}\n</code></pre> <p>Info</p> <p>More information about RestActions can be found here</p> </li> <li> <p>Register your listener with either <code>JDABuilder.addEventListeners(new MyListener())</code> or <code>JDA.addEventListeners(new MyListener())</code> (see Events)</p> </li> </ol>"},{"location":"using-jda/interactions/","title":"Interactions","text":"<p>Interactions differ between JDA v4 and JDA v5.  This page covers JDA v5.</p> <p>This guide will give you a brief introduction to an API for adding and handling interactions in Discord. Interactions are a way to integrate your bot features directly into the Discord User Interface. These things include features such as:</p> <ul> <li>Slash Commands</li> <li>Slash Command Autocomplete</li> <li>Context Menus</li> <li>Buttons</li> <li>Select Menus (Dropdowns)</li> <li>Modals</li> </ul>"},{"location":"using-jda/interactions/#ephemeral-messages","title":"Ephemeral Messages","text":"<p>Ephemeral messages are only visible to the user who used your Interaction. They are similar to the messages Discord sends you when you update your nickname with <code>/nick</code>.</p> <p>There are many limitations to ephemeral messages, a few of which are listed below:</p> <ul> <li>Cannot be reacted to</li> <li>Cannot be retrieved</li> <li>Will be removed after a client restart</li> </ul> <p>Example</p> <p></p> <p>You can only create ephemeral messages with interactions. For example with <code>deferReply(true)</code>, <code>reply(content).setEphemeral(true)</code>, or <code>getHook().sendMessage(content).setEphemeral(true)</code>. For convenience, you can also configure the <code>InteractionHook</code> to default to ephemeral messages with <code>hook.setEphemeral(true)</code>.</p>"},{"location":"using-jda/interactions/#command-interactions","title":"Command Interactions","text":""},{"location":"using-jda/interactions/#slash-commands","title":"Slash Commands","text":"<p>A slash command is something you might already be familiar with from the olden times of Discord. Commands such as <code>/shrug</code> or <code>/me</code> have existed for quite a long time. With Slash Command interactions you can now make your very own commands like this! But these commands come with some limitations, which I have explained in this gist: Slash Command Limitations</p> <p></p> <p>All of these commands are used through the interactions API. They do not require the user to send an actual message in the channel and you don't have to do string parsing either.</p> <p>To create commands you need to make some API requests. There are 2 types of commands you can create called global commands and guild commands.</p> <ul> <li>Global: These commands are available in every server your bot is in (regardless of sharding!) and direct message (Private Channels).</li> <li>Guild: These commands are only in the specific guild that you created them in and cannot be used in direct messages.</li> </ul>"},{"location":"using-jda/interactions/#creating-slash-commands","title":"Creating Slash Commands","text":"<p>You can create commands through these methods in JDA:</p> <ul> <li><code>updateCommands()</code></li> <li><code>upsertCommand(name, description)</code></li> </ul> <p>Example</p> JavaKotlin <pre><code>guild.updateCommands().addCommands(\n        Commands.slash(\"echo\", \"Repeats messages back to you.\")\n            .addOption(OptionType.STRING, \"message\", \"The message to repeat.\")\n            .addOption(OptionType.INTEGER, \"times\", \"The number of times to repeat the message.\")\n            .addOption(OptionType.BOOLEAN, \"ephemeral\", \"Whether or not the message should be sent as an ephemeral message.\"),\n        Commands.slash(\"animal\", \"Finds a random animal\")\n             .addOptions(\n                 new OptionData(OptionType.STRING, \"type\", \"The type of animal to find\")\n                     .addChoice(\"Bird\", \"bird\")\n                     .addChoice(\"Big Cat\", \"bigcat\")\n                     .addChoice(\"Canine\", \"canine\")\n                     .addChoice(\"Fish\", \"fish\")\n             )\n).queue();\n</code></pre> <pre><code>guild.updateCommands().addCommands(\n        Commands.slash(\"echo\", \"Repeats messages back to you.\")\n            .addOption(OptionType.STRING, \"message\", \"The message to repeat.\")\n            .addOption(OptionType.INTEGER, \"times\", \"The number of times to repeat the message.\")\n            .addOption(OptionType.BOOLEAN, \"ephemeral\", \"Whether or not the message should be sent as an ephemeral message.\"),\n        Commands.slash(\"animal\", \"Finds a random animal\")\n             .addOptions(\n                 OptionData(OptionType.STRING, \"type\", \"The type of animal to find\")\n                     .addChoice(\"Bird\", \"bird\")\n                     .addChoice(\"Big Cat\", \"bigcat\")\n                     .addChoice(\"Canine\", \"canine\")\n                     .addChoice(\"Fish\", \"fish\")\n             )\n).queue()\n</code></pre> <p>You need to call these on a <code>JDA</code> instance to create global commands, and on a <code>Guild</code> instance to create guild commands . Your bot needs the <code>applications.commands</code> scope in addition to the <code>bot</code> scope for your bot invite link. Example: https://discord.com/oauth2/authorize?client_id=123456789&amp;scope=bot+applications.commands</p> <p>Warning</p> <p>If the <code>applications.commands</code> scope is not present, JDA will fail to create guild commands, and global commands will not be shown in the client.</p> <p>Once a command is created, it will continue persisting even when your bot restarts. Commands stay until the bot is either kicked or your bot explicitly deletes the command. You don't need to create your commands every time your bot starts!</p>"},{"location":"using-jda/interactions/#responding-to-slash-commands","title":"Responding to Slash Commands","text":"<p>When a user tries to use one of your commands you will receive a <code>SlashCommandInteractionEvent</code>. This event needs to be handled by your event listener. The flow of a slash command response is as follows:</p> <ol> <li> <p>Acknowledge the command</p> <p>This means you need to either reply or deferReply. You only have 3 SECONDS to acknowledge a command. Since some commands may take longer than 3 seconds you may want to use <code>deferReply</code> to have more time for handling. This will instead send a <code>Thinking...</code> message to channel which is later updated by a followup message (see step 2).</p> <p></p> </li> <li> <p>Send followup messages</p> <p>Sometimes commands need more than one response. However, you can only send one initial reply to a command. To send additional messages for the same slash command you need to use the <code>InteractionHook</code> attached to the event with <code>getHook()</code>. This is a webhook that allows you to send additional messages for up to 15 minutes after the initial command.</p> </li> </ol> <p>When you use <code>deferReply</code> the first message sent to this webhook will act identically to using <code>editOriginal(...)</code>. The message you send is also referred to as deferred reply in this case. Your deferred reply will edit your initial <code>Thinking...</code> message instead of sending an additional message to channel. This means you cannot use <code>setEphemeral</code> on this deferred reply since you already decided whether the message will be ephemeral through your initial acknowledgment.</p> <p>Example Reply</p> JavaKotlin <pre><code>public class SayCommand extends ListenerAdapter {\n    @Override\n    public void onSlashCommandInteraction(SlashCommandInteractionEvent event) {\n        if (event.getName().equals(\"say\")) {\n          event.reply(event.getOption(\"content\").getAsString()).queue(); // reply immediately\n        }\n    }\n}\n</code></pre> <pre><code>object SayCommand : ListenerAdapter() {\n  override fun onSlashCommandInteraction(event: SlashCommandInteractionEvent) {\n    if (event.name == \"say\") {\n      event.reply(event.getOption(\"content\")!!.asString).queue()\n    }\n  }\n}\n</code></pre> <p>Example Deferred Reply</p> JavaKotlin <pre><code>public class TagCommand extends ListenerAdapter {\n  @Override\n  public void onSlashCommandInteraction(SlashCommandInteractionEvent event) {\n    if (event.getName().equals(\"tag\")) {\n      event.deferReply().queue(); // Tell discord we received the command, send a thinking... message to the user\n      String tagName = event.getOption(\"name\").getAsString();\n      TagDatabase.fingTag(tagName,\n        (tag) -&gt; event.getHook().sendMessage(tag).queue() // delayed response updates our inital \"thinking...\" message with the tag value\n      );\n    }\n  }\n}\n</code></pre> <pre><code>object TagCommand : ListenerAdapter() {\n    override fun onSlashCommandInteraction(event: SlashCommandInteractionEvent) {\n        if (event.name == \"tag\") {\n            event.deferReply().queue() // Tell discord we received the command, send a thinking... message to the user\n            val tagName = event.getOption(\"name\")!!.asString\n            TagDatabase.fingTag(tagName) { tag -&gt;\n                event.hook.sendMessage(tag).queue() // delayed response updates our inital \"thinking...\" message with the tag value\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/interactions/#managing-slash-command-permissions","title":"Managing Slash Command Permissions","text":"<p>Restricting slash commands to specific roles or members is up to the admins of the guild.  However, bots can specify a set of permissions that sets who can use those commands by default.</p> <p>Note that members with <code>Permission.ADMINISTRATOR</code> can always use commands, and they can override which roles or members can run the command.  JDA only changes the default members and roles that can access it.</p> <p>In order to set this default, <code>.setDefaultPermissions()</code> can be called on the command before you register it.  <code>DefaultMemberPermissions.DISABLED</code> can be used to only allow administrators by default, and <code>DefaultMemberPermissions.ENABLED</code> can be used to allow all members by default.</p> <p>Example</p> <p>This will restrict the command so that only members with the <code>Permission.MANAGE_CHANNEL</code> and <code>Permission.MODERATE_MEMBERS</code> permissions can use the command:</p> JavaKotlin <pre><code>guild.updateCommands().addCommands(\n    Commands.slash(\"meeting\", \"Creates a new channel for an emergency meeting\")\n        .setDefaultPermissions(DefaultMemberPermissions.enabledFor(Permission.MANAGE_CHANNEL, Permission.MODERATE_MEMBERS))\n).queue();\n</code></pre> <pre><code>guild.updateCommands().addCommands(\n    Commands.slash(\"meeting\", \"Creates a new channel for an emergency meeting\")\n        .setDefaultPermissions(DefaultMemberPermissions.enabledFor(Permission.MANAGE_CHANNEL, Permission.MODERATE_MEMBERS))\n).queue()\n</code></pre>"},{"location":"using-jda/interactions/#slash-command-autocomplete","title":"Slash Command Autocomplete","text":"<p>Slash command autocompletion is a feature that allows users to begin typing arguments to a command, and suggestions from the bot will be displayed to the user, in-client.</p> <p>Any slash command arguments using the <code>String</code>, <code>Integer</code> or <code>Number</code> types can be autocompleted.  By default, options are not autocompleted.  In order to make an option autocompleted, <code>OptionData#setAutoComplete(true)</code> may be used.</p> <p></p>"},{"location":"using-jda/interactions/#handling-autocomplete","title":"Handling Autocomplete","text":"<p>As the user is typing an argument that has autocomplete enabled for it, the bot will receive an <code>CommandAutoCompleteInteractionEvent</code>. This event isn't fired for each keystroke, but is sent when Discord determines the user has paused typing for a bit.</p> <p>Autocompletions can suggest up to 25 options, and users do not have to send a command with one of the options.</p> <p>Example</p> <p>Creating the command:</p> JavaKotlin <pre><code>guild.updateCommands().addCommands(\n        Commands.slash(\"fruit\", \"find a given fruit\")\n            .addOption(OptionType.STRING, \"name\", \"fruit to find\", true, true)\n).queue();\n</code></pre> <pre><code>guild.updateCommands().addCommands(\n        Commands.slash(\"fruit\", \"find a given fruit\")\n            .addOption(OptionType.STRING, \"name\", \"fruit to find\", required=true, autocomplete=true)\n).queue()\n</code></pre> <p>Handling the event:</p> JavaKotlin AutoCompleteBot.java<pre><code>public class AutoCompleteBot extends ListenerAdapter {\n    private String[] words = new String[]{\"apple\", \"apricot\", \"banana\", \"cherry\", \"coconut\", \"cranberry\"};\n\n    @Override\n    public void onCommandAutoCompleteInteraction(CommandAutoCompleteInteractionEvent event) {\n        if (event.getName().equals(\"fruit\") &amp;&amp; event.getFocusedOption().getName().equals(\"name\")) {\n            List&lt;Command.Choice&gt; options = Stream.of(words)\n                    .filter(word -&gt; word.startsWith(event.getFocusedOption().getValue())) // only display words that start with the user's current input\n                    .map(word -&gt; new Command.Choice(word, word)) // map the words to choices\n                    .collect(Collectors.toList());\n            event.replyChoices(options).queue();\n        }\n    }\n}\n</code></pre> AutoCompleteBot.kt<pre><code>object AutoCompleteBot : ListenerAdapter() {\n    private val words = arrayOf(\"apple\", \"apricot\", \"banana\", \"cherry\", \"coconut\", \"cranberry\")\n\n    override fun onCommandAutoCompleteInteraction(event: CommandAutoCompleteInteractionEvent) {\n        if (event.name == \"fruit\" &amp;&amp; event.focusedOption.name == \"name\") {\n            event.replyChoiceStrings(words.filter {\n                it.startsWith(event.focusedOption.value)\n            }).queue()\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/interactions/#context-menus","title":"Context Menus","text":"<p>Context Menu commands are a special type of command that can be invoked on a user or message by right-clicking on them. These commands take no arguments, and are useful for providing a quick way to perform actions on a user or message.</p> <p></p> <p></p> <p>Example</p> <p>Creating the commands: <pre><code>guild.updateCommands().addCommands(\n        Commands.context(Command.Type.USER, \"Get user avatar\"),\n        Commands.message(\"Count words\")\n).queue()\n</code></pre></p> <p>Handling the events:</p> JavaKotlin ContextMenuBot.java<pre><code>public class ContextMenuBot extends ListenerAdapter {\n    @Override\n    public void onUserContextInteraction(UserContextInteractionEvent event) {\n        if (event.getName().equals(\"Get user avatar\")) {\n            event.reply(\"Avatar: \" + event.getTarget().getEffectiveAvatarUrl()).queue();\n        }\n    }\n\n    @Override\n    public void onMessageContextInteraction(MessageContextInteractionEvent event) {\n        if (event.getName().equals(\"Count words\")) {\n            event.reply(\"Words: \" + event.getTarget().getContentRaw().split(\"\\\\s+\").length).queue();\n        }\n    }\n}\n</code></pre> ContextMenuBot.kt<pre><code>object ContextMenuBot : ListenerAdapter() {\n    override fun onUserContextInteraction(event: UserContextInteractionEvent) {\n        if (event.name == \"Get user avatar\") {\n            event.reply(\"Avatar: \" + event.target.effectiveAvatarUrl).queue()\n        }\n    }\n\n    override fun onMessageContextInteraction(event: MessageContextInteractionEvent) {\n        if (event.name == \"Count words\") {\n            event.reply(\"Words: \" + event.target.contentRaw.split(Regex(\"\\\\s+\")).size).queue()\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/interactions/#component-interactions","title":"Component Interactions","text":"<p>To add components to a message you can use up to 5 ActionRows.</p> <p>You can add multiple ActionRows with either <code>setComponents</code> or <code>addComponents</code>. For the common case of a single ActionRow you can also use <code>setActionRow(Component...)</code> or <code>addActionRow(Component...)</code>.</p> <p>Each ActionRow can hold up to a certain amount of components:</p> <ul> <li>5 Buttons</li> <li>1 Select Menu (Dropdown)</li> <li>1 Text Input (Restricted to Modals)</li> </ul> <p>These component interactions offer 4 response types:</p> <ul> <li>Reply</li> <li>Deferred Reply</li> <li>Edit Message</li> <li>Deferred Edit Message</li> </ul> <p>The reply and deferred reply responses are identical to the Slash-Commands response types. However, these new edit response types are used to update the existing message the component is attached to. If you just want to acknowledge that the component was successfully interacted with, you can simply call <code>deferEdit()</code> without any further updates, which will prevent the interaction from failing on the user side.</p> <p>To properly use an interactive component, you need to use the Component ID (aka Custom ID). This ID can also be used to then identify which component was pressed by the user.</p> <p>Such Component ID is provided by <code>getComponentId()</code> on every Component Interaction.</p> <p>Keep in mind that these Component IDs must be unique across all components in one message.</p>"},{"location":"using-jda/interactions/#buttons","title":"Buttons","text":"<p>Each button can be enabled or disabled, have a specific style, label, and emoji:</p> <p></p>"},{"location":"using-jda/interactions/#handling-buttoninteractionevent","title":"Handling ButtonInteractionEvent","text":"<p>When a user presses one of these buttons, you will receive a <code>ButtonInteractionEvent</code> for the respective interaction.</p> <p>Each non-link button requires such an ID in order to be used.</p> <p>Example</p> JavaKotlin <pre><code>public class HelloBot extends ListenerAdapter {\n    @Override\n    public void onSlashCommandInteraction(SlashCommandInteractionEvent event) {\n        if (event.getName().equals(\"hello\")) {\n            event.reply(\"Click the button to say hello\")\n                .addActionRow(\n                  Button.primary(\"hello\", \"Click Me\"), // Button with only a label\n                  Button.success(\"emoji\", Emoji.fromFormatted(\"&lt;:minn:245267426227388416&gt;\"))) // Button with only an emoji\n                .queue();\n        } else if (event.getName().equals(\"info\")) {\n            event.reply(\"Click the buttons for more info\")\n                .addActionRow( // link buttons don't send events, they just open a link in the browser when clicked\n                    Button.link(\"https://github.com/discord-jda/JDA\", \"GitHub\")\n                      .withEmoji(Emoji.fromFormatted(\"&lt;:github:849286315580719104&gt;\")), // Link Button with label and emoji\n                    Button.link(\"https://docs.jda.wiki/\", \"Javadocs\")) // Link Button with only a label\n                .queue();\n        }\n    }\n\n    @Override\n    public void onButtonInteraction(ButtonInteractionEvent event) {\n        if (event.getComponentId().equals(\"hello\")) {\n            event.reply(\"Hello :)\").queue(); // send a message in the channel\n        } else if (event.getComponentId().equals(\"emoji\")) {\n            event.editMessage(\"That button didn't say click me\").queue(); // update the message\n        }\n    }\n}\n</code></pre> <pre><code>object HelloBot: ListenerAdapter() {\n    override fun onSlashCommandInteraction(event: SlashCommandInteractionEvent) {\n        if (event.name == \"hello\") {\n            event.reply(\"Click the button to say hello\")\n                .addActionRow(\n                    Button.primary(\"hello\", \"Click Me\"),  // Button with only a label\n                    Button.success(\"emoji\", Emoji.fromFormatted(\"&lt;:minn:245267426227388416&gt;\"))) // Button with only an emoji\n                .queue()\n        } else if (event.name == \"info\") {\n            event.reply(\"Click the buttons for more info\")\n                .addActionRow( // link buttons don't send events, they just open a link in the browser when clicked\n                    Button.link(\"https://github.com/discord-jda/JDA\", \"GitHub\")\n                        .withEmoji(Emoji.fromFormatted(\"&lt;:github:849286315580719104&gt;\")),  // Link Button with label and emoji\n                    Button.link(\"https://docs.jda.wiki/\", \"Javadocs\")) // Link Button with only a label\n                .queue()\n        }\n    }\n\n    override fun onButtonInteraction(event: ButtonInteractionEvent) {\n        when (event.componentId) {\n            \"hello\" -&gt; event.reply(\"Hello :)\").queue() // send a message in the channel\n            \"emoji\" -&gt; event.editMessage(\"That button didn't say click me\").queue() // update the message\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/interactions/#select-menus-dropdowns","title":"Select Menus (Dropdowns)","text":"<p>Select Menus can be disabled.</p> <p>It's possible to set the minimum and maximum number of options to be selected.</p> <p>There are two implementations for SelectMenus:</p> <ul> <li><code>StringSelectMenu</code> supports custom string choices</li> <li><code>EntitySelectMenu</code> derives its choices from mentionable entities (such as <code>User</code>s, <code>Channel</code>s, etc)</li> </ul>"},{"location":"using-jda/interactions/#string-select-menus","title":"String Select Menus","text":"<p>String Select Menus support up to 25 options.</p> <p>Each option can have its own label, description, and emoji. There can be multiple options selected and set as default.</p> <p></p>"},{"location":"using-jda/interactions/#entity-select-menus","title":"Entity Select Menus","text":"<p>Entity Select Menus do not support custom choices. Instead, they derive their choices from mentionable Discord entities such as <code>User</code>s, <code>Channel</code>s, etc.</p> <p></p> <p>You can specify which entity types you wish to appear as choices by specifying the <code>SelectTarget</code>s in <code>EntitySelectMenu.create</code>. If you create an entity select menu with channel type targets, the same menu may not utilize user or role select targets, and vice versa.</p> <p>You can limit channel selections to specific channel types by using the <code>setChannelTypes</code> method on <code>EntitySelectMenu.Builder</code>.</p> <p>Info</p> <p>These Select Menus do not support setting a custom list of options or customizing the appearance in any way. They always show the complete list of possible entities for the specified types.</p>"},{"location":"using-jda/interactions/#handling-select-menus","title":"Handling Select Menus","text":"<p>When a user selects their options from a dropdown and submits their choices, you will receive either one of the following for the respective interaction:</p> <ul> <li>A <code>StringSelectInteractionEvent</code> for a String Select Menu interaction</li> <li>An <code>EntitySelectInteractionEvent</code> for an Entity Select Menu interaction</li> </ul> <p>Both interaction events provide the values that were selected by the user.</p> <p>Example String Select Handling</p> JavaKotlin <pre><code>public class StringDropdownBot extends ListenerAdapter {\n    @Override\n    public void onSlashCommandInteraction(SlashCommandInteractionEvent event) {\n        if (event.getName().equals(\"food\")) {\n            event.reply(\"Choose your favorite food\")\n                .addActionRow(\n                    StringSelectMenu.create(\"choose-food\")\n                      .addOption(\"Pizza\", \"pizza\", \"Classic\") // SelectOption with only the label, value, and description\n                      .addOptions(SelectOption.of(\"Hamburger\", \"hamburger\") // another way to create a SelectOption\n                            .withDescription(\"Tasty\") // this time with a description\n                            .withEmoji(Emoji.fromUnicode(\"\\uD83C\\uDF54\")) // and an emoji\n                            .withDefault(true)) // while also being the default option\n                    .build())\n                .queue();\n        }\n    }\n\n    @Override\n    public void onStringSelectInteraction(StringSelectInteractionEvent event) {\n        if (event.getComponentId().equals(\"choose-food\")) {\n            event.reply(\"You chose \" + event.getValues().get(0)).queue();\n        }\n    }\n}\n</code></pre> <pre><code>object StringDropdownBot : ListenerAdapter() {\n    override fun onSlashCommandInteraction(event: SlashCommandInteractionEvent) {\n        if (event.name == \"food\") {\n            val selectMenu = StringSelectMenu.create(\"choose-food\")\n                .addOption(\"Pizza\", \"pizza\", \"Classic\") // SelectOption with only the label, value, and description\n                .addOptions(SelectOption.of(\"Hamburger\", \"hamburger\") // another way to create a SelectOption\n                    .withDescription(\"Tasty\") // this time with a description\n                    .withEmoji(Emoji.fromUnicode(\"\\uD83C\\uDF54\")) // and an emoji\n                    .withDefault(true)) // while also being the default option\n                .build()\n\n            event.reply(\"Choose your favorite food\")\n                .addActionRow(selectMenu)\n                .queue()\n        }\n    }\n\n    override fun onStringSelectInteraction(event: StringSelectInteractionEvent) {\n        if (event.componentId == \"choose-food\") {\n            event.reply(\"You chose \" + event.values[0]).queue()\n        }\n    }\n}\n</code></pre> <p>Example Entity Select Handling</p> JavaKotlin <pre><code>public class EntityDropdownBot extends ListenerAdapter {\n    @Override\n    public void onSlashCommandInteraction(SlashCommandInteractionEvent event) {\n        if (event.getName().equals(\"highfive\")) {\n            event.reply(\"Choose the user to high-five\")\n                .addActionRow(\n                    EntitySelectMenu.create(\"choose-user\", SelectTarget.USER)\n                    .build())\n                .queue();\n        }\n    }\n\n    @Override\n    public void onEntitySelectInteraction(EntitySelectInteractionEvent event) {\n        if (event.getComponentId().equals(\"choose-user\")) {\n            // Mentions provide the selected values using familiar getters\n            List&lt;User&gt; users = event.getMentions().getUsers();\n            event.reply(\"You high-fived \" + users.get(0).getAsMention()).queue();\n        }\n    }\n}\n</code></pre> <pre><code>object EntityDropdownBot : ListenerAdapter() {\n    override fun onSlashCommandInteraction(event: SlashCommandInteractionEvent) {\n        if (event.name == \"food\") {\n            val selectMenu = EntitySelectMenu.create(\"choose-user\", SelectTarget.USER)\n                .build()\n\n            event.reply(\"Choose the user to high-five\")\n                .addActionRow(selectMenu)\n                .queue()\n        }\n    }\n\n    override fun onEntitySelectInteraction(event: EntitySelectInteractionEvent) {\n        if (event.componentId == \"choose-user\") {\n            // Mentions provide the selected values using familiar getters\n            val users = event.mentions.users;\n            event.reply(\"You high-fived \" + users.first().asMention).queue()\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/interactions/#modals","title":"Modals","text":"<p>Modals are pop-ups that appear in a user's Discord client.</p> <p></p> <p>A modal usually consists of a list of <code>Label</code> components, each of which contain a labelled field such as <code>TextInput</code> or <code>StringSelectMenu</code>.</p>"},{"location":"using-jda/interactions/#replying-with-a-modal","title":"Replying with a Modal","text":"<p>Example</p> JavaKotlin <pre><code>public class SupportCommand extends ListenerAdapter {\n    @Override\n    public void onSlashCommandInteraction(SlashCommandInteractionEvent event) {\n        if (event.getName().equals(\"modmail\")) {\n            TextInput subject = TextInput.create(\"subject\", TextInputStyle.SHORT)\n                    .setPlaceholder(\"Subject of this ticket\")\n                    .setMinLength(10)\n                    .setMaxLength(100) // or setRequiredRange(10, 100)\n                    .build();\n\n            TextInput body = TextInput.create(\"body\", TextInputStyle.PARAGRAPH)\n                    .setPlaceholder(\"Your concerns go here\")\n                    .setMinLength(30)\n                    .setMaxLength(1000)\n                    .build();\n\n            Modal modal = Modal.create(\"modmail\", \"Modmail\")\n                    .addComponents(Label.of(\"Subject\", subject), Label.of(\"Body\", body))\n                    .build();\n\n            event.replyModal(modal).queue();\n        }\n    }\n}\n</code></pre> <pre><code>object SupportCommand : ListenerAdapter() {\n    override fun onSlashCommandInteraction(event: SlashCommandInteractionEvent) {\n        if (event.name == \"modmail\") {\n            val subject = TextInput.create(\"subject\", TextInputStyle.SHORT)\n                .setPlaceholder(\"Subject of this ticket\")\n                .setMinLength(10)\n                .setMaxLength(100) // or setRequiredRange(10, 100)\n                .build()\n\n            val body = TextInput.create(\"body\", TextInputStyle.PARAGRAPH)\n                .setPlaceholder(\"Your concerns go here\")\n                .setMinLength(30)\n                .setMaxLength(1000)\n                .build()\n\n            val modal = Modal.create(\"modmail\", \"Modmail\")\n                .addComponents(Label.of(\"Subject\", subject), Label.of(\"Body\", body))\n                .build()\n\n            event.replyModal(modal).queue()\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/interactions/#handling-modalinteractionevent","title":"Handling ModalInteractionEvent","text":"<p>When the user clicks the \"Submit\" button on the Modal, you will receive an <code>ModalInteractionEvent</code>, containing all the values the user put in it.</p> <p>Warning</p> <p>Acknowledging a <code>ModalInteractionEvent</code> is necessary. Failing to respond to the event will not close it on the user's client, and will show them an error.</p> <p>Info</p> <p>If the Modal originated from a Component-Interaction (Buttons, SelectMenus), it is possible to acknowledge the interaction using an edit to the original Message using <code>editMessage()</code> or similar.</p> <p>Example</p> JavaKotlin <pre><code>public class ModalListener extends ListenerAdapter {\n    @Override\n    public void onModalInteraction(@Nonnull ModalInteractionEvent event) {\n        if (event.getModalId().equals(\"modmail\")) {\n            String subject = event.getValue(\"subject\").getAsString();\n            String body = event.getValue(\"body\").getAsString();\n\n            createSupportTicket(subject, body);\n\n            event.reply(\"Thanks for your request!\").setEphemeral(true).queue();\n        }\n    }\n}\n</code></pre> <pre><code>object ModalListener : ListenerAdapter() {\n    override fun onModalInteraction(event: ModalInteractionEvent) {\n        if (event.modalId == \"modmail\") {\n            val subject = event.getValue(\"subject\") ?: return\n            val body = event.getValue(\"body\") ?: return\n\n            createSupportTicket(subject, body)\n\n            event.reply(\"Thanks for your request!\").setEphemeral(true).queue()\n        }\n    }\n}\n</code></pre>"},{"location":"using-jda/making-a-music-bot/","title":"What do I need to get started?","text":"<ol> <li> <p>Set up your project: </p> <ul> <li>IntelliJ IDEA</li> <li>Eclipse</li> <li>Netbeans</li> </ul> </li> <li> <p>Set up JDA</p> </li> <li>Once you have your project you will need an additional dependency for your AudioSendHandler<ul> <li>If you don't want to implement it yourself, use LavaPlayer</li> </ul> </li> </ol>"},{"location":"using-jda/making-a-music-bot/#connecting-to-a-voicechannel","title":"Connecting to a VoiceChannel","text":"<ol> <li>Getting a VoiceChannel (<code>guild</code> references an instance of <code>Guild</code>)<ul> <li>By the channel id: <code>guild.getVoiceChannelById(CHANNEL_ID)</code> <code>VoiceChannel myChannel = guild.getVoiceChannelById(CHANNEL_ID);</code></li> <li>By the channel name: <code>guild.getVoiceChannelsByName(CHANNEL_NAME, true)</code> <code>VoiceChannel myChannel = guild.getVoiceChannelsByName(CHANNEL_NAME, true).get(0);</code></li> <li>By the voice state of a member <code>member.getVoiceState().getChannel()</code> <code>VoiceChannel myChannel = member.getVoiceState().getChannel();</code></li> </ul> </li> <li>Retrieve the <code>AudioManager</code> <code>AudioManager audioManager = guild.getAudioManager();</code></li> <li>Open an audio connection <code>audioManager.openAudioConnection()</code> <code>audioManager.openAudioConnection(myChannel);</code></li> </ol> <p>Note</p> <p>It may be important to do certain permission checks before trying to open an audio connection! It may result in a PermissionException throw otherwise!</p>"},{"location":"using-jda/making-a-music-bot/#sending-audio-to-an-open-audio-connection","title":"Sending Audio to an Open Audio Connection","text":"<p>Note</p> <p>For LavaPlayer read here</p> <ol> <li>Retrieve the <code>AudioManager</code> <code>AudioManager audioManager = guild.getAudioManager();</code></li> <li>Create a new AudioSendHandler instance for your implementation. </li> <li>Register your AudioSendHandler:    <code>audioManager.setSendingHandler(myAudioSendHandler)</code> You may only use one AudioSendHandler per Guild and not use the same instance on another Guild!      Doing that will result in speedup due to multiple send threads pulling from the same instance!</li> </ol>"},{"location":"using-jda/making-a-music-bot/#a-working-example","title":"A Working Example","text":"<pre><code>public class MusicBot extends ListenerAdapter \n{\n    public static void main(String[] args)\n    throws IllegalArgumentException, LoginException, RateLimitedException\n    {\n        JDABuilder.createDefault(args[0]) // Use token provided as JVM argument\n            .addEventListeners(new MusicBot()) // Register new MusicBot instance as EventListener\n            .build(); // Build JDA - connect to discord\n    }\n\n    @Override\n    public void onMessageReceived(MessageReceivedEvent event) \n    {\n        // Make sure we only respond to events that occur in a guild\n        if (!event.isFromGuild()) return;\n        // This makes sure we only execute our code when someone sends a message with \"!play\"\n        if (!event.getMessage().getContentRaw().startsWith(\"!play\")) return;\n        // Now we want to exclude messages from bots since we want to avoid command loops in chat!\n        // this will include own messages as well for bot accounts\n        // if this is not a bot make sure to check if this message is sent by yourself!\n        if (event.getAuthor().isBot()) return;\n        Guild guild = event.getGuild();\n        // This will get the first voice channel with the name \"music\"\n        // matching by voiceChannel.getName().equalsIgnoreCase(\"music\")\n        VoiceChannel channel = guild.getVoiceChannelsByName(\"music\", true).get(0);\n        AudioManager manager = guild.getAudioManager();\n\n        // MySendHandler should be your AudioSendHandler implementation\n        manager.setSendingHandler(new MySendHandler());\n        // Here we finally connect to the target voice channel \n        // and it will automatically start pulling the audio from the MySendHandler instance\n        manager.openAudioConnection(channel);\n    }\n}\n</code></pre> <p>Important</p> <p>This example expects you to have your own AudioSendHandler implementation. It is crucial you only use one AudioSendHandler per Guild!</p>"},{"location":"using-jda/making-a-music-bot/#using-lavaplayer","title":"Using LavaPlayer","text":"<ol> <li>Set up LavaPlayer</li> <li>Implement an AudioSendHandler <ul> <li>Example</li> </ul> </li> <li>Connect to a voice channel</li> <li>Register your AudioSendHandler</li> <li>Use the LavaPlayer resources: How To Use LavaPlayer</li> </ol>"},{"location":"using-jda/making-a-music-bot/#more-example-implementations-can-be-found-in-existing-bots-like","title":"More example implementations can be found in existing bots like:","text":"<ul> <li>AudioEchoExample<ul> <li>Source</li> </ul> </li> <li>Clarity by @jagrosh<ul> <li>GitHub </li> <li>Wiki </li> </ul> </li> <li>FredBoat by @freyacodes<ul> <li>GitHub</li> <li>relevant package</li> </ul> </li> </ul>"},{"location":"using-jda/paginating-entities/","title":"PaginationAction","text":"<p>In some scenarios the Discord API allows to paginate endpoints to retrieve entities in bulks. Such an endpoint is especially often used for retrieving past messages in the client by scrolling up.</p> <p>In JDA we allow iterating such endpoints with the Iterable <code>PaginationAction</code> implementations. Using it inside an enhanced for-loop is a blocking and expensive operation so it is recommended to use the async methods instead.</p> <p>Example Messages</p> <pre><code>/**\n* Retrieves up to 1000 messages from the provided MessageChannel\n* and then provides them to the callback.\n*/\npublic void get1000(MessageChannel channel, Consumer&lt;List&lt;Message&gt;&gt; callback)\n{\n    List&lt;Message&gt; messages = new ArrayList&lt;&gt;(1000);\n    channel.getIterableHistory().cache(false).forEachAsync((message) -&gt;\n    {\n        messages.add(message);\n        return messages.size() &lt; 1000;\n    }).thenRun(() -&gt; callback.accept(messages));\n}\n\nget1000(channel, (messages) -&gt; channel.purgeMessages(messages));\n</code></pre>"},{"location":"using-jda/paginating-entities/#entity-cache","title":"Entity Cache","text":"<p>Note</p> <p>PaginationActions support the Stream api which was introduced in Java 1.8.  Stream requires blocking operations and can take long to finish.</p> <p>Every PaginationAction has a cache of already retrieved entities. This cache is enabled by default but can be disabled via <code>PaginationAction.cache(false)</code>.  Doing so is recommended if the cache is not needed.</p> <p>To retrieve all cached entities use <code>PaginationAction.getCached()</code>. This returns an immutable List representing all cached entities (thread-safe but expanding). You may also get the first/last entity with <code>getLast()</code> and <code>getFirst()</code> for convenience.</p> <p>By default the PaginationAction will retrieve the maximum amount of entities per request (complete/queue). It is advised to lower this limit if only a small number of entities is required. (See <code>limit(int)</code>).</p> <p>Usage examples</p> <pre><code>public class PaginationUtil\n{\n    // Calls the callback if the user has reacted\n    public static void ifReacted(MessageReaction reaction, User user, Runnable callback)\n    {\n        reaction.getUsers().cache(false).forEachAsync(u -&gt; {\n            if (u.equals(user)) {\n                callback.run(); // user has reacted -&gt; call the callback\n                return false; // end iteration\n            }\n            return true; // continue iteration\n        });\n    }\n\n    // Blocking iteration using the Iterable interface (not recommended)\n    public static List&lt;Message&gt; forEachMessage(int limit, MessageChannel channel, Consumer&lt;Message&gt; action)\n    {\n        MessagePaginationAction paginator = channel.getIterableHistory();\n        for (Message message : paginator)\n        {\n            action.apply(message);\n            if (--limit &lt;= 0) break;\n        }\n        return paginator.getCached();\n    }\n}\n</code></pre>"},{"location":"using-jda/separation-of-concerns/","title":"Separation of Concerns","text":"<p>In JDA we follow the pattern of Separation of Concerns (SoC) for our entities. This means that updates and moderation all happens in dedicated classes rather than on the entities themselves (with a few exceptions like deletion)</p> <p>Each entity that can be updated directly has a Manager instance which can be used to update one or more of the entity properties such as its name.</p>"},{"location":"using-jda/separation-of-concerns/#managers","title":"Managers","text":"<p>The managers in JDA are useful to update entities. Without many complications, you can update many of properties in a single RestAction execution (HTTP request).</p>"},{"location":"using-jda/separation-of-concerns/#updating-an-entity","title":"Updating an Entity","text":"<p>We will make a small example here on how to update the name and the topic of a TextChannel.</p> <pre><code>public void updateChannel(TextChannel channel) {\n    ChannelManager manager = channel.getManager(); // get the manager\n    manager.setName(\"testing-2\").setTopic(\"This is a testing channel, no memes allowed\"); // set the new values\n    manager.queue(); // execute update, this updates both name and topic\n}\n</code></pre> <p>Note</p> <p><code>queue()</code> is async so the update is not done when this method returns!</p>"},{"location":"using-jda/separation-of-concerns/#re-usability-of-managers","title":"Re-usability of Managers","text":"<p>Every manager in JDA is cached for re-use and can be updated for an interval and then executed upon command, very useful for bots!</p> Example State Machine <pre><code>import net.dv8tion.jda.api.events.message.MessageReceivedEvent;\nimport net.dv8tion.jda.api.hooks.ListenerAdapter;\nimport net.dv8tion.jda.api.entities.*;\nimport net.dv8tion.jda.api.MessageBuilder;\nimport net.dv8tion.jda.api.requests.restaction.MessageAction;\n\n// derived with permission from https://gist.github.com/MinnDevelopment/190b79109b17c3bb446eea13be57c43c\npublic class UpdateStateMachine extends ListenerAdapter {\nprivate final TextChannel channel;\nprivate String name = null;\nprivate String topic = null;\nprivate int state = 0;\n\n    public UpdateStateMachine(TextChannel channel) {\n        this.channel = channel;\n    }\n\n    @Override\n    public void onMessageReceived(MessageReceivedEvent event) {\n        if (!event.isFromGuild()) return;\n        if (!event.getChannel().equals(channel)) return;\n        String content = event.getMessage().getContentRaw();\n        if (!content.startsWith(\"!update \")) return;\n        String parts[] = content.split(\" \", 2);\n        String arguments = parts.length &gt; 1 ? parts[1] : \"\";\n        switch (state) {\n            case 0: // setting mode\n                if (arguments.equals(\"done\")) {              // finish update\n                    state = 2; // enter update mode\n                    sendStatus().append(\"\\nType `!update yes` to finish!\").queue();\n                } else if (arguments.equals(\"reset\")) {      // reset state\n                    state = 1; // enter reset mode\n                    sendStatus().append(\"\\nType `!update yes` to reset!\").queue();\n                } else if (arguments.startsWith(\"topic \")) { // update topic\n                    this.topic = arguments.split(\" \", 2)[1];\n                    channel.getManager().setTopic(this.topic);\n                } else if (arguments.startsWith(\"name \")) {  // update name\n                    this.name = arguments.split(\" \", 3)[1];\n                    channel.getManager().setName(this.name);\n                } else {\n                    channel.sendMessage(\"I'm sorry I did not understand.\").queue();\n                }\n                break;\n            case 1: // reset mode\n                state = 0;\n                if (arguments.equals(\"yes\"))  // we should reset\n                    resetState();\n                else                          // nevermind, we are not done\n                    channel.sendMessage(\"Ok, what do you want to change?\").queue();\n                break;\n            case 2: // update mode\n                state = 0;\n                if (arguments.equals(\"yes\")) // we should update\n                    channel.getManager().queue((v) -&gt; resetState());\n                else                         // nevermind, we are not done\n                    channel.sendMessage(\"Ok, what do you want to change?\").queue();\n                break;\n        }\n    }\n\n    protected void resetState() {\n        channel.getManager().reset();\n        this.name = null;\n        this.topic = null;\n    }\n\n    private MessageAction sendStatus() {\n        MessageBuilder builder = new MessageBuilder();\n        builder.append(\"**Current Status**\");\n        if (name != null || topic != null) {\n            StringBuilder changes = new StringBuilder();\n            if (name != null)\n                changes.append(\"name -&gt; \").append(name).append(\"\\n\");\n            if (topic != null)\n                changes.append(\"topic -&gt; \").append(topic);\n            builder.appendCodeBlock(changes, \"\");\n        }\n        return builder.sendTo(channel);\n    }\n}\n</code></pre>"},{"location":"using-jda/separation-of-concerns/#exceptions-to-soc-pattern","title":"Exceptions to SoC Pattern","text":"<p>The only exceptions we have are deletion and creation. All entities are deleted directly using its delete() method, for instance Channel.delete().</p> <p>You can create copies of entities in the same fashion with one twist. Some <code>createCopy()</code> methods allow you to modify the new copy before execution of the RestAction</p> <p>Note</p> <p>This will copy the provided <code>Channel</code> and set its name to the provided <code>newName</code>!</p> <pre><code>public void copyChannel(Channel channel, String newName) {\n    channel.createCopy().setName(newName).queue();\n}\n</code></pre> <p>These things can be overlooked, so we do recommend inspecting the return type of these operations: <code>getManager()</code>, <code>create...()</code>, <code>delete()</code>, <code>ban(...)</code>, <code>kick(...)</code> and similar when you use them so that you are not caught out.</p>"},{"location":"using-jda/troubleshooting/","title":"Troubleshooting","text":"<p>This is a collection of common issues and recommended solutions.</p> <p>Didn't find an answer? Try asking in our Discord server</p>"},{"location":"using-jda/troubleshooting/#shutdown-but-the-process-doesnt-exit","title":"Shutdown but the process doesn't exit","text":"<p>When you call <code>JDA.shutdown()</code> or <code>JDA.shutdownNow()</code> the JDA instance will stop all of its threads. However, if HTTP/2 was used by the <code>OkHttpClient</code> instance it will keep the JVM running due to a timeout thread for http connections. This can be terminated by shutting it down manually:</p> <pre><code>OkHttpClient client = jda.getHttpClient();\nclient.connectionPool().evictAll();\nclient.dispatcher().executorService().shutdown();\n</code></pre>"},{"location":"using-jda/troubleshooting/#noclassdeffounderror-or-classnotfoundexception-on-startup","title":"NoClassDefFoundError or ClassNotFoundException on startup","text":"<p>An error like <code>java.lang.NoClassDefFoundError: net/dv8tion/jda/api/JDABuilder</code> or similar means you are not including your dependencies or transitive dependencies in the archive.</p> Gradle (build.gradle)Maven (pom.xml)Jar <p>With Gradle this can be fixed by using the shadow plugin and building your jar with <code>shadowJar</code> instead. The jar will then be present in the <code>build/libs</code> directory with a name like <code>example-1.0-all.jar</code></p> <p>With Maven you need the shade plugin in your pom to add dependencies to your package task. You can see the shade plugin being applied in this example pom.xml</p> <p>You need to use the <code>-withDependencies.jar</code> rather than the normal one.</p>"},{"location":"using-jda/troubleshooting/#discord-issues-and-api-limitations","title":"Discord Issues and API Limitations","text":""},{"location":"using-jda/troubleshooting/#the-provided-token-is-invalid","title":"The provided token is invalid!","text":"<pre><code>javax.security.auth.login.LoginException: The provided token is invalid!\n</code></pre> <p>This exception indicates that the token you have used in your <code>JDABuilder</code> is not a valid bot token. Usually, this means you tried using the secret instead of the bot token. To get your token, follow these steps:</p> <ol> <li>Open the Application Dashboard</li> <li>Select your application</li> <li>On the left side, click the Bot tab</li> <li>If you don't have a bot yet, you must create one</li> <li>Once you have a bot, there is a token section. Click COPY.</li> <li>The token is now in your clipboard and you can paste it into your code</li> </ol> <p>If you follow these steps and you still get the same exception, it could be due to one of these problems:</p> <ul> <li>You included excess whitespace in your string. The token string should not include any newlines or spaces.</li> <li>You were banned from the API or your server is hosted on a public hosting platform like Glitch or Heroku.</li> <li>The token is not for a bot account, we do not support client accounts.</li> </ul> <p>A valid token looks like this:</p> <pre><code>NDkyNzQ3NzY5MDM2MDEzNTc4.Xw2cUA.LLslVBE1tfFK20sGsNm-FVFYdsA\n</code></pre> <p>Caution</p> <p>NEVER SHARE YOUR TOKEN WITH ANYONE. DO NOT COMMIT IT AND PUSH IT TO GITHUB. DO NOT SHOW IT TO ANYONE UNDER ANY CIRCUMSTANCES.</p>"},{"location":"using-jda/troubleshooting/#cant-get-emoji-from-message","title":"Can't get emoji from message","text":"<p>Methods such as <code>Mentions.getCustomEmojis()</code> and <code>Mentions.getCustomEmojisBag()</code> only include custom emoji which have to be uploaded to a guild by a moderator. Unicode emoji such as \ud83d\udc4d are not included and require using a 3rd party library to be located in a string. You can use emoji-java to extract unicode emoji from a message.</p> <p>An example use-case including a code sample can be found in this answer to a related question on StackOverflow</p>"},{"location":"using-jda/troubleshooting/#event-handling-and-restactions","title":"Event Handling and RestActions","text":""},{"location":"using-jda/troubleshooting/#restaction-queue-returned-failure","title":"RestAction queue returned failure","text":"<p>When JDA encounters an issue while executing a <code>RestAction</code> it will emit an error through the failure callback. You can handle this by adding a second callback to <code>queue()</code>, for example: <code>message.delete().queue(v -&gt; System.out.println(\"success\"), ContextException.herePrintingTrace\u200b());</code>.</p> <p>Example</p> <pre><code>public void deleteMessage(Message message) {\n    message.delete().queue(null, (exception) -&gt; {\n        message.getChannel().sendMessage(\"There was an error \" + exception).queue();\n    });\n}\n</code></pre> <p>You can use ErrorHandler to handle or ignore specific ErrorResponse failures.</p>"},{"location":"using-jda/troubleshooting/#nothing-happens-when-using-x","title":"Nothing happens when using X","text":"<p>In JDA we make use of async rate-limit handling through the use of the common RestAction class. When you have code such as <code>channel.sendMessage(\"hello\");</code> or <code>message.delete();</code> nothing actually happens. This is because both <code>sendMessage(...)</code> as well as <code>delete()</code> return a <code>RestAction</code> instance. You are not done here since that class is only an intermediate step to executing your request. Here you can decide to use async <code>queue()</code> (recommended) or <code>submit()</code> or the blocking <code>complete()</code> (not recommended).</p> <p>You might notice that <code>queue()</code> returns <code>void</code>. This is because it's async and uses callbacks instead. Read More</p> <p>If you do have a <code>queue()</code> then maybe your code doesn't even run? Try putting a <code>System.out.println(\"debug\")</code> right before and after your code and see if it prints. If not, then read this My event listener code is not executed.</p>"},{"location":"using-jda/troubleshooting/#my-event-listener-code-is-not-executed","title":"My event listener code is not executed","text":"<p>There are many reasons why your event listener might not be executed but here are the most common issues:</p> <ol> <li>You are using a deprecated or removed part of JDA, such as <code>new JDABuilder(...)</code>.     Use the replacement that is documented, for example <code>createDefault(token)</code>.</li> <li>You are using the wrong login token.     If the token is for another bot which doesn't have access to the desired guilds then the event listener code cannot run.</li> <li>Your bot is not actually in the guild.     Make sure your bot is online and has access to the resource you are trying to interact with.</li> <li>You never registered your listener.     Use <code>jda.addEventListener(new MyListener())</code> on either the <code>JDABuilder</code> or <code>JDA</code> instance</li> <li>You did not override the correct method.     Use <code>@Override</code> and see if it fails. Your method has to use the correct name and parameter list defined in <code>ListenerAdapter</code>. Read More.</li> <li>You don't actually extend <code>EventListener</code> or <code>ListenerAdapter</code>.     Your class should either use <code>extends ListenerAdapter</code> or <code>implements EventListener</code>.</li> <li>You are missing a required <code>GatewayIntent</code> for this event.     Make sure that you <code>enableIntents(...)</code> on the <code>JDABuilder</code> to allow the events to be received.</li> <li>The event has other requirements that might not be satisfied such as the cache not being enabled.     Please check the requirements on the event documentation.</li> </ol> <p>If none of the above apply to you then you might have an issue in your listener's code, at that point you should use a debugger.</p>"},{"location":"using-jda/troubleshooting/#missed-2-heartbeats-trying-to-reconnect","title":"Missed 2 heartbeats! Trying to reconnect...","text":"<p>This warning implies your event thread is too busy and will block critical events from being received. You should try to limit blocking calls and make sure your event handlers don't take up too much time. Do profiling to figure out what takes so long or create a thread dump when you get this warning to see where the issue is.</p> <p>By default, all events are handled on the same thread they get received and handled on. If you block this thread for too long then JDA cannot keep up with important lifecycle events sent by Discord. Either you start writing non-blocking code (replace <code>complete()</code> with <code>queue()</code> etc.) or you use a thread pool for your event handling.</p>"},{"location":"using-jda/troubleshooting/#listener-must-implement-eventlistener","title":"Listener must implement EventListener","text":"<pre><code>Exception in thread \"main\" java.lang.IllegalArgumentException: Listener must implement EventListener\n        at net.dv8tion.jda.api.hooks.InterfacedEventManager.register(InterfacedEventManager.java:62)\n        at net.dv8tion.jda.internal.hooks.EventManagerProxy.register(EventManagerProxy.java:52)\n        at net.dv8tion.jda.internal.JDAImpl.addEventListener(JDAImpl.java:810)\n        at net.dv8tion.jda.api.JDABuilder.lambda$build$0(JDABuilder.java:1841)\n        at java.base/java.lang.Iterable.forEach(Iterable.java:75)\n        at net.dv8tion.jda.api.JDABuilder.build(JDABuilder.java:1841)\n</code></pre> <p>When you get an exception like this, that means one of the event listeners you registered does not implement the <code>EventListener</code> interface provided by JDA.</p> <p>This is not a valid event listener class:</p> <pre><code>public class MyListener {\n   ...\n}\n</code></pre> <p>You can either use ListenerAdapter or EventListener:</p> <pre><code>import net.dv8tion.jda.api.hooks.ListenerAdapter;\n\npublic class MyListener extends ListenerAdapter {\n  ...\n}\n</code></pre> <p>When using EventListener make sure you actually imported the correct interface from JDA and not <code>java.util.EventListener</code>:</p> <pre><code>import net.dv8tion.jda.api.events.GenericEvent;\nimport net.dv8tion.jda.api.hooks.EventListener;\n\npublic class MyListener extends EventListener {\n  @Override\n  public void onEvent(GenericEvent event) {\n    ...\n  }\n}\n</code></pre> <p>Read More</p>"},{"location":"using-jda/troubleshooting/#illegalstateexception-zip-file-closed","title":"IllegalStateException: zip file closed","text":"<p>This error can occur when trying to reload a plugin in various minecraft frameworks. The cause of this error is a quirk with how plugin loading works, where it disables class loading when disabling the plugin. This causes problems when JDA hasn't finished shutting down all of its internal threads yet.</p> <p>The best way to handle this is to use <code>awaitShutdown</code>:</p> <pre><code>// Initial shutdown, allowing for some RestActions to still go through\njda.shutdown();\n// Wait up to 10 seconds for requests to finish\nif (!jda.awaitShutdown(Duration.ofSeconds(10))) {\n   jda.shutdownNow(); // Cancel request queue\n   jda.awaitShutdown(); // Wait until shutdown is complete (indefinitely)\n}\n</code></pre> <p>Alternatively, you can also use <code>shutdownNow()</code> immediately and then use <code>awaitShutdown()</code>. This will prevent any currently queued requests from executing and immediately stop the threads.</p> <p>In general, using <code>/reload</code> is frowned upon due to its unsafe and buggy nature. It is recommended to use alternative measures to reload your plugin, as recommended in this article by the WorldEdit author.</p>"},{"location":"using-jda/troubleshooting/#i-cant-get-the-previous-message-content-from-deleteupdate","title":"I can't get the previous message content from delete/update","text":"<p>When Discord emits a <code>message_delete</code> or <code>message_update</code> they only provide the new content of the message. Since JDA does not keep a cache of messages it is unable to provide the previous content. Instead you will have to track content of messages yourself.</p>"},{"location":"using-jda/troubleshooting/#preventing-use-of-complete-in-callback-threads","title":"Preventing use of complete() in callback threads","text":"<p>The following code will illustrate an issue where callbacks might cause a deadlock</p> <pre><code>class Main {\n    public static main(String[] args) {\n        JDA api = JDABuilder.createDefault(BOT_TOKEN)\n                .setCallbackPool(Executors.newSingleThreadScheduledExecutor()) // (1)\n                .build().awaitReady();\n        TextChannel channel = api.getTextChannelById(CHANNEL_ID);\n        channel.sendMessage(\"hello there\").queue((message) -&gt; { // (2)\n            System.out.println(\"Hello\");\n            message.editMessage(\"general kenobi\").complete(); // (3) deadlock\n            System.out.println(\"World!!!!\"); // never printed\n        });\n   }\n}\n</code></pre> <p>You can test this yourself on 3.8.0 and see it fail.</p> <p>Since we decided to use a single-thread pool (1) we only have one thread to execute callbacks. This thread is used by the first callback (2) and cannot be used for the second callback (3).</p> <p>Due to this reason we simply don't allow using <code>complete()</code> in any callback threads at all. If you use callbacks you should use <code>queue()</code>.</p>"},{"location":"using-jda/troubleshooting/#ratelimits","title":"RateLimits","text":""},{"location":"using-jda/troubleshooting/#hit-the-websocket-ratelimit","title":"Hit the WebSocket RateLimit","text":"<p>When you update your game or online status you emit a socket message to Discord. If you do that often enough you hit a limit and JDA has to backoff for 60 seconds.</p> <p>Things that contribute to the WebSocket RateLimit include:</p> <ul> <li><code>AudioManager.openAudioConnection(...)</code></li> <li><code>AudioManager.closeAudioConnection()</code></li> <li><code>AudioManager.setSelfMuted(...)</code></li> <li><code>AudioManager.setSelfDeafened(...)</code></li> <li>Any setter method on <code>Presence</code>.</li> </ul> <p>It is also possible that you get spammed by this warning if you use <code>ChunkingFilter.ALL</code> (this is done when using <code>create(token, intents)</code>). If your bot is in more than 120 guilds then this warning is unavoidable when using member chunking. It is recommended to use <code>setChunkingFilter(ChunkingFilter.NONE)</code> to reduce the startup time and get rid of this warning. If chunking on startup is absolutely necessary, you have to accept this warning.</p> <p>There are many ways to retrieve members: Loading Members</p> <p>I explained this in a bit more detail in issue #1290</p> <p>To make chunking a little more efficient, you can additionally enable the <code>GatewayIntent.GUILD_PRESENCES</code>. This will load all online members for each guild directly, instead of relying on additional member chunk requests, which can be a significant boost to reduce startup time and potentially reduce these warnings.</p>"},{"location":"using-jda/troubleshooting/#encountered-429-or-encountered-global-rate-limit","title":"Encountered 429 or Encountered global rate limit","text":"<p>When the internal jda rate-limiter fails to predict a rate limit bucket the HTTP response is <code>429: TOO MANY REQUESTS</code>. This means the request has to be retried. If you see this a lot (many times per minute), then JDA might have an issue with the rate limit handling of that route. If you use <code>setRelativeRateLimit(false)</code> it could also mean that your clock is not properly synchronizing with NTP.</p> <p>Encountering the global rate-limit is something JDA cannot predict or prevent. This rate-limit implies you sent too many requests in total across all routes. Discord limits how much HTTP traffic a client is allowed to do and will tell us to limit all requests for a specified time interval. You should avoid hitting this too often.</p>"},{"location":"using-jda/troubleshooting/#intents-and-caching","title":"Intents and Caching","text":""},{"location":"using-jda/troubleshooting/#cannot-get-reference-as-it-has-already-been-garbage-collected","title":"Cannot get reference as it has already been Garbage Collected","text":"<p>Due to how we structure cache we sometimes have to invalidate our entire cache (that's just how Discord works). When you store references to JDA entities for a long period of time such as a field you will suffer with the error <code>java.lang.IllegalStateException: Cannot get reference as it has already been Garbage Collected</code> once the entity was removed from the JDA cache. We highly recommend to store only the parts you actually need of the specific entity such as <code>id</code> and use something like <code>event.getJDA().getRoleById(id)</code>.</p> <p>Entities that should not be stored for a long period of time include:</p> <ul> <li>Role</li> <li>Channel (any type of channel)</li> <li>Guild</li> <li>RichCustomEmoji</li> <li>User</li> <li>Message</li> </ul> <p>Instead store IDs of the entities, or for messages simply the parts you need such as content.</p>"},{"location":"using-jda/troubleshooting/#usersmembers-not-in-cache","title":"Users/Members not in cache","text":"<p>The default behavior in <code>createDefault</code> is to only cache members connected to voice channels. If you need members to be cached, for example to lookup users by roles, then you have to enable this explicitly.</p> <p>I explained this in this wiki page and this stackoverflow answer.</p> <p>There are many ways you can retrieve members dynamically: Loading Members</p>"},{"location":"using-jda/troubleshooting/#cannot-get-message-content-attempting-to-access-message-content-without-gatewayintent","title":"Cannot get message content / Attempting to access message content without GatewayIntent","text":"<p>When you receive this warning, that means you tried to access the content of a message without the privileged <code>GatewayIntent.MESSAGE_CONTENT</code>.</p> <pre><code>Attempting to access message content without GatewayIntent.MESSAGE_CONTENT.\nDiscord now requires to explicitly enable access to this using the MESSAGE_CONTENT intent.\nUseful resources to learn more:\n    - https://support-dev.discord.com/hc/en-us/articles/4404772028055-Message-Content-Privileged-Intent-FAQ\n    - https://jda.wiki/using-jda/gateway-intents-and-member-cache-policy/\n    - https://jda.wiki/using-jda/troubleshooting/#im-getting-closecode4014-disallowed-intents\nOr suppress this warning if this is intentional with Message.suppressContentIntentWarning()\n</code></pre> <p>As of JDA version 5.0.0-alpha.14, you are required to enable this intent explicitly with <code>enableIntents(GatewayIntent.MESSAGE_CONTENT)</code> on your <code>JDABuilder</code> or <code>DefaultShardManagerBuilder</code>.</p> <p>This affects anyone who accesses these methods on messages:</p> <ul> <li><code>getContentRaw</code>, <code>getContentDisplay</code>, <code>getContentStripped</code>, and <code>getMentions().getCustomEmojis()</code></li> <li><code>getActionRows</code>, and <code>getButtons</code></li> <li><code>getAttachments</code></li> <li><code>getEmbeds</code></li> </ul> <p>You are also required to enable this in your application dashboard. Note, however, that this is a privileged intent and will require a valid use-case for your bot to be verified in over 75 servers.</p>"},{"location":"using-jda/troubleshooting/#im-getting-closecode4014-disallowed-intents","title":"I'm getting CloseCode(4014 / Disallowed intents...)","text":"<p>This means you tried to use <code>GatewayIntent.GUILD_MEMBERS</code>, <code>GatewayIntent.GUILD_PRESENCES</code>, or <code>GatewayIntent.MESSAGE_CONTENT</code> without enabling it in your application dashboard. To use these privileged intents you first have to enable them.</p> <ol> <li>Open the application dashboard</li> <li>Select your bot application</li> <li>Open the Bot tab</li> <li>Under the Privileged Gateway Intents section, enable the intents that you are using in your bot. Toggle on SERVER MEMBERS INTENT, PRESENCE INTENT, or MESSAGE CONTENT INTENT depending on your needs.</li> </ol> <p>If you use these intents you are limited to 100 guilds on your bot. To allow the bot to join more guilds while using this intent you have to verify your bot. This will be available in your application dashboard when the bot joins at least 75 guilds.</p>"},{"location":"using-jda/troubleshooting/#interactions-and-slash-commands","title":"Interactions and Slash Commands","text":""},{"location":"using-jda/troubleshooting/#the-application-did-not-respond","title":"The application did not respond","text":"<p>This means you didn't acknowledge or reply to an interaction in time. You only have 3 seconds to reply or acknowledge. You have to use <code>event.deferReply().queue()</code>, <code>event.deferEdit().queue()</code>, <code>event.editMessage(...).queue()</code>, or <code>event.reply(...).queue()</code>. (If you don't <code>queue()</code> it won't do it) Make sure your event listener code is executed.</p>"},{"location":"using-jda/troubleshooting/#unknown-interaction","title":"Unknown Interaction","text":"<p>This exception can happen due to two reasons:</p>"},{"location":"using-jda/troubleshooting/#the-interaction-took-longer-than-3-seconds-to-be-acknowledged","title":"The interaction took longer than 3 seconds to be acknowledged","text":"<p>Possible reasons why your response was too slow:</p> <ul> <li>JDA's WebSocket thread was blocked for too long, when you see the <code>This application did not respond</code> on Discord,  make a thread dump and look at the stack trace around <code>JDA MainWS-ReadThread</code> to see where it may have blocked</li> <li>Your interaction took too long to acknowledge, you can use <code>event.deferReply(boolean).queue()</code> to extend the response time to 15 minutes</li> </ul> <p>Making a thread dump</p> <p>See <code>How do I make a thread dump?</code> in the FAQ.</p>"},{"location":"using-jda/troubleshooting/#the-interaction-was-acknowledged-by-another-process-running-the-same-bot","title":"The interaction was acknowledged by another process running the same bot","text":"<p>You can confirm this by checking if your bot replied, or the three dots in a button disappeared without saying <code>This interaction failed</code>, or you see '[Bot] is thinking...' for more than 3 seconds.</p> <p>To resolve this, try stopping all current processes for the bot that could be responsible, or resetting your bot token.</p> <p>Resetting your token</p> <p>You can reset your token in your application dashboard.</p>"},{"location":"using-jda/troubleshooting/#interaction-followup-messages-timed-out","title":"Interaction Followup Messages Timed out","text":"<p>This means you sent followup messages through <code>InteractionHook.sendMessage(...)</code> or similar but never acknowledged the interaction.</p>"},{"location":"using-jda/using-new-features/","title":"Using New Features","text":"<p>When contributors are making new features, like introducing modals,  you might be interested in trying out or testing these features before they get released.</p>"},{"location":"using-jda/using-new-features/#using-jitpack","title":"Using JitPack","text":"<p>Using JitPack, you can get a build of any fork of JDA, on any branch, on any commit. It is still highly recommended that you use a build tool such as Gradle or Maven.</p>"},{"location":"using-jda/using-new-features/#getting-the-necessary-info","title":"Getting the Necessary Info","text":"<p>Let's take the PR for the Discord modals as an example.</p> <p></p> <p>You will need the author's name, which here is <code>xirado</code>.</p>"},{"location":"using-jda/using-new-features/#getting-the-latest-version","title":"Getting the Latest Version","text":"<p>Next, head to the <code>Commits</code> tab.</p> <p></p> <p>You can now scroll down to the bottom, as to find the latest commit hash.  It should look like this:</p> <p></p> <p>Here you can see the 7 first characters of the latest commit are <code>36eea2a</code>.</p>"},{"location":"using-jda/using-new-features/#putting-it-together","title":"Putting It Together","text":"<p>So far we have:</p> <ul> <li>PR author name: <code>xirado</code></li> <li>Version (7 character commit hash): <code>36eea2a</code></li> </ul> <p>You can now add the dependency to your project using your favorite build tool, but don't forget to remove your current JDA dependency first.</p> <p>Template:</p> GradleMaven <pre><code>repositories {\n    mavenCentral()\n    maven { url 'https://jitpack.io' }\n}\n\ndependencies {\n    implementation(\"com.github.AuthorName:JDA:CommitHash\")\n}\n</code></pre> <p>Put this in your <code>&lt;repositories&gt;</code> tag    </p> <pre><code>&lt;repository&gt;\n    &lt;id&gt;jitpack&lt;/id&gt;\n    &lt;url&gt;https://jitpack.io&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <p>and then this, in your <code>&lt;dependencies&gt;</code> tag</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.AuthorName&lt;/groupId&gt;\n    &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n    &lt;version&gt;CommitHash&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>With our example:</p> GradleMaven <pre><code>repositories {\n    mavenCentral()\n    maven { url 'https://jitpack.io' }\n}\n\ndependencies {\n    implementation(\"com.github.xirado:JDA:36eea2a\")\n}\n</code></pre> <p>Put this in your <code>&lt;repositories&gt;</code> tag    </p> <pre><code>&lt;repository&gt;\n    &lt;id&gt;jitpack&lt;/id&gt;\n    &lt;url&gt;https://jitpack.io&lt;/url&gt;\n&lt;/repository&gt;\n</code></pre> <p>and then this, in your <code>&lt;dependencies&gt;</code> tag</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.github.xirado&lt;/groupId&gt;\n    &lt;artifactId&gt;JDA&lt;/artifactId&gt;\n    &lt;version&gt;36eea2a&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"using-jda/using-restaction/","title":"What is a RestAction?","text":"<p>If you understand RestAction you understand JDA.</p> <p>In JDA 3.0 we introduced the new <code>RestAction</code> class which basically is a terminal between the JDA user and the Discord REST API. The <code>RestAction</code> is a step between specifying what the user wants to do and executing it, it allows the user to specify how JDA should deal with their <code>Request</code>.</p> <p>However this only works if you actually tell the <code>RestAction</code> to do something. That is why we recommend checking out whether or not something in JDA returns a <code>RestAction</code>. If that is the case you have to execute it using one of the <code>RestAction</code> execution operations:</p> <code>queue()</code>, <code>queue(Consumer)</code>, <code>queue(Consumer, Consumer)</code> These operations are asynchronous and will not execute within the same Thread. This means that you cannot use procedural logic when you use <code>queue()</code>, unless you use the callback Consumers. Only similar requests are internally executed in sequence such as sending messages in the same channel or adding reactions to the same message. <code>submit()</code> Provides request future to cancel tasks later and avoid callback hell. <code>complete()</code> This operation will block the current Thread until the request has been finished and will return the response type. <p>Note</p> <p>We recommend using <code>queue()</code> or <code>submit()</code> when possible as blocking the current Thread can cause downtime and will use more resources.</p> <p>Since 4.1.1 you can use a few RestAction operators to avoid callback hell with queue:</p> <ul> <li><code>map</code>     Convert the result of the <code>RestAction</code> to a different value</li> <li><code>flatMap</code>     Chain another <code>RestAction</code> on the result</li> <li><code>delay</code>     Delay the element of the previous step</li> </ul> <p>JavaDocs: https://docs.jda.wiki/net/dv8tion/jda/api/requests/RestAction.html</p>"},{"location":"using-jda/using-restaction/#auditlog-reasons","title":"AuditLog Reasons","text":"<p>Some operations return a special <code>RestAction</code> implementation called <code>AuditableRestAction</code>. This extension allows to set a reason field for that action.</p> <p>Example</p> <pre><code>public class ModerationUtil\n{\n    public static void deleteMessage(Message message, String reason)\n    {\n        message.delete().reason(reason).queue();\n    }\n\n    public static void ban(Guild guild, User user, String reason)\n    {\n        guild.ban(user, 7, reason).queue();\n    }\n}\n</code></pre>"},{"location":"using-jda/using-restaction/#using-queue","title":"Using <code>queue()</code>","text":"<p>The most common way to execute a <code>RestAction</code> is by simply calling <code>.queue()</code> after the operation:  <pre><code>public void sendMessage(MessageChannel channel, String message) \n{\n    channel.sendMessage(message).queue();\n}\n</code></pre></p> <p>This will always simply execute the <code>RestAction&lt;Message&gt;</code> which was returned by <code>MessageChannel.sendMessage(String)</code>. Note that this might happen after calling <code>sendMessage(MessageChannel, String)</code> because <code>queue()</code> is asynchronous!</p> <p>You: Why can't I access the Message that was sent with <code>queue()</code>? Minn: Use the success callback!</p> <p>Is one of the common conversations we had when people started using JDA 3.0.</p> <p>You: What does that mean?</p> <p>A success callback is what we call the primary <code>Consumer</code> that can be passed to a <code>queue()</code> statement: <pre><code>public void sendAndLog(MessageChannel channel, String message) \n{\n    channel.sendMessage(message).queue(new Consumer&lt;Message&gt;()\n    {\n        @Override\n        public void accept(Message t)\n        {\n            System.out.printf(\"Sent Message %s\\n\", t);\n        }\n    });\n}\n</code></pre></p> <p>Here we used an inline implementation of <code>Consumer&lt;Message&gt;</code> that handles the response of a REST Request. The method <code>Consumer.accept(Message)</code> is automatically called once the response has been received by the JDA Requester.</p> <p>Minn: But that looks really ugly... You: Yeah but it works!!</p> <p>Since JDA requires you to use Java 1.8 we can use one of the new features: Lambda Expressions <pre><code>public void sendAndLog(MessageChannel channel, String message)\n{\n    // Here we use a lambda expressions which names the callback parameter -response- and uses that as a reference\n    // in the callback body -System.out.printf(\"Sent Message %s\\n\", response)-\n    Consumer&lt;Message&gt; callback = (response) -&gt; System.out.printf(\"Sent Message %s\\n\", response);\n    channel.sendMessage(message).queue(callback); // ^ calls that\n}\n</code></pre></p> <p>You: Wow that looks so much better! Minn: Yes, please learn more about lambda expressions: lambda quickstart</p> <p>Example: Sending a Private Message</p> <p><pre><code>public void sendPrivateMessage(User user, String content)\n{\n    // openPrivateChannel provides a RestAction&lt;PrivateChannel&gt; \n    // which means it supplies you with the resulting channel\n    user.openPrivateChannel().queue((channel) -&gt;\n    {\n        // value is a parameter for the `accept(T channel)` method of our callback.\n        // here we implement the body of that method, which will be called later by JDA automatically.\n        channel.sendMessage(content).queue();\n        // here we access the enclosing scope variable -content-\n        // which was provided to sendPrivateMessage(User, String) as a parameter\n    });\n}\n</code></pre> Since this only calls a single method in the callback you can use the short form: <pre><code>public void sendPrivateMessage(User user, String content)\n{\n    // notice that we are not placing a semicolon (;) in the callback this time!\n    user.openPrivateChannel().queue( (channel) -&gt; channel.sendMessage(content).queue() );\n}\n</code></pre></p>"},{"location":"using-jda/using-restaction/#using-submit","title":"Using <code>submit()</code>","text":"<p>Sometimes execution needs to be cancelled if it isn't required anymore. This can be challenging to do if you use <code>queue()</code> or <code>complete()</code>. In <code>submit()</code> JDA will provide a <code>CompletableFuture</code> (aka promise) which allows the cancellation of a request.</p> <p>If you don't need to use the <code>CompletableFuture</code> you may use <code>queue()</code> instead!</p> <p>Example</p> <pre><code>public void setTestingChannel(TextChannel channel)\n{\n    channel.getManager().setName(\"testing-channel\").queue( (v) -&gt;\n        channel.sendMessage(\"Update Channel\").queue( (m) -&gt;\n            m.delete().queueAfter(30, TimeUnit.SECONDS, (t) -&gt;\n                logChannel.sendMessage(\"Deleted Response in %s\", channel).queue()\n            )\n        )\n    );\n}\n\n// turns into\npublic void setTestingChannel(TextChannel channel)\n{\n    channel.getManager().setName(\"testing-channel\").submit()                   // CompletableFuture&lt;Void&gt;\n        .thenCompose((v) -&gt; channel.sendMessage(\"Update Channel\").submit()) // CompletableFuture&lt;Message&gt;\n        .thenCompose((m) -&gt; m.delete().submitAfter(30, TimeUnit.SECONDS))   // CompletableFuture&lt;Void&gt;\n        .thenCompose((v) -&gt; logChannel.sendMessage(\"Deleted Response in %s\", channel).submit())\n        .whenComplete((s, error) -&gt; {\n            // this will be called for every termination (success/failure)\n            // if the result is successful the error will be null\n            // otherwise you should handle the error here to prevent it from being eaten and never printed\n            if (error != null) error.printStackTrace();\n        });\n}\n</code></pre> <p>Note</p> <p>You can do the same with <code>RestAction#flatMap</code> in 4.1.1</p> <pre><code>public class RateLimitListener extends ListenerAdapter\n{\n    private final long guildId;\n    private final long userId;\n    private final Queue&lt;RequestFuture&lt;Void&gt;&gt; tasks = new LinkedList&lt;&gt;();\n\n    public RateLimitListener(Guild guild, User user)\n    {\n        guildId = guild.getIdLong();\n        userId = user.getIdLong();\n        // only store IDs as JDA objects can be disposed by cache invalidation\n        //when disposed the entity is not usable anymore, since we only need the id this is good enough\n    }\n\n    @Override\n    public void onGuildMessageReceived(GuildMessageReceivedEvent event)\n    {\n        if (event.getAuthor().getIdLong() != userId)\n            return; // ignore other users\n        if (event.getGuild().getIdLong() != guildId)\n            return; // ignore other guilds\n        RequestFuture&lt;Void&gt; task = event.getMessage().delete().submit();\n        tasks.add(task); // add task to cancel queue in case user gets banned\n        task.thenRun(() -&gt; tasks.remove(task)); // remove once completed\n    }\n\n    @Override\n    public void onGuildBan(GuildBanEvent event)\n    {\n        if (event.getUser().getIdLong() != userId)\n            return; // ignore other users\n        if (event.getGuild().getIdLong() != guildId)\n            return; // ignore other guilds\n\n        // stop deleting messages for banned user\n        RequestFuture&lt;Void&gt; current;\n        while ((current = tasks.poll()) != null)\n            current.cancel(true); \n        tasks.clear();\n\n        // remove this as listener, our task has completed!\n        event.getJDA().removeEventListener(this);\n    }\n}\n</code></pre>"},{"location":"using-jda/using-restaction/#using-complete","title":"Using <code>complete()</code>","text":"<p>The <code>complete()</code> operation is simply for your convenience. It will block the Thread that you call it on which means it will not be able to continue with other tasks in the meantime. If you don't use the return value or don't need the request to be completed before continuing with other operations it is recommended to use <code>queue()</code> instead!</p> <p>Example</p> <p><pre><code>public void setTestingChannel(TextChannel channel)\n{\n    channel.getManager().setName(\"testing-channel\").queue( (v) -&gt;\n        channel.sendMessage(\"Update Channel\").queue( (m) -&gt;\n            m.delete().queueAfter(30, TimeUnit.SECONDS, (t) -&gt;\n                logChannel.sendMessage(\"Deleted Response in %s\", channel).queue()\n            )\n        )\n    );\n}\n\npublic void setTestingChannelBlocking(TextChannel channel)\n{\n    channel.getManager().setName(\"testing-channel\").complete();\n    Message m = channel.sendMessage(\"Update Channel\").complete();\n    m.delete().completeAfter(30, TimeUnit.SECONDS);\n    logChannel.sendMessage(\"Deleted Response in %s\", channel).queue();\n    // note how we used queue in the end because we don't need it sequenced anymore.\n}\n</code></pre> This is called a callback hell <pre><code>public Message sendAndLog(MessageChannel channel, String message)\n{\n    Message response = channel.sendMessage(message).complete();\n    System.out.printf(\"Sent Message %s\\n\", response);\n    return response;\n}\n</code></pre> <pre><code>public PermissionOverride getOverride(Channel channel, Member member)\n{\n    final PermissionOverride override = channel.getPermissionOverride(member);\n\n    if (override == null)\n        return channel.createPermissionOverride(member).complete();\n\n    return override;\n}\n</code></pre> You can do this asynchronously by using a <code>CompletableFuture</code>:</p> <pre><code>public CompletableFuture&lt;PermissionOverride&gt; getOverride(Channel channel, Member member)\n{\n    final PermissionOverride override = channel.getPermissionOverride(member);\n\n    if (override == null)\n        return channel.createPermissionOverride(member).submit();\n\n    return CompletableFuture.completedFuture(override);\n}\n\ngetOverride(channel, member).thenAccept(override -&gt; ...);\n</code></pre>"},{"location":"using-jda/using-restaction/#using-completeafter-submitafter-and-queueafter","title":"Using <code>completeAfter</code>, <code>submitAfter</code> and <code>queueAfter</code>","text":"<p>These three methods are also known under the term of Planned Execution  as they use a ScheduledExecutorService to schedule calls to either complete or queue.</p> <p>There are three possible ways to plan a RestAction execution</p> <code>completeAfter(long, TimeUnit)</code> Blocks and executes on the current Thread, similar to <code>complete()</code>! Similar to using <code>Thread.join()</code> this will block until the action has completed. <code>submitAfter(long, TimeUnit)</code>, <code>submitAfter(long, TimeUnit, ScheduledExecutorService)</code> Creates a <code>DelayedCompletableFuture&lt;T&gt;</code> which will hold the response type as its generic value. This means using <code>get()</code> on the returned Future will cause the current thread to block and await the execution of the RestAction and receive the response type. <code>queueAfter(long, TimeUnit)</code>, <code>queueAfter(long, TimeUnit, Consumer&lt;T&gt;)</code>, <code>queueAfter(long, TimeUnit, Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;)</code> Schedules the RestAction execution to be started after the specified delay, this will not block the thread and handle the execution in the background. You can optionally provide a ScheduledExecutorService to any of the <code>queueAfter</code> operations as the last argument. <p>When no ScheduledExecutorService is provided, these operations will use the default internal JDA ScheduledExecutorService that is also used to execute queue callback consumers.</p> <p>Example <code>completeAfter</code></p> <pre><code>public Message waitForEdit(Message message)\n{\n    return message.editMessage(\"5 Minutes are over\").completeAfter(5, TimeUnit.MINUTES);\n}\n</code></pre> <p>Example <code>queueAfter</code></p> <pre><code>public void remind(User user, String reminder, long delay, TimeUnit unit)\n{\n    user.openPrivateChannel().queue(\n        (channel) -&gt; channel.sendMessage(reminder).queueAfter(delay, unit)\n    );\n}\n\npublic void remindAlternate(User user, String reminder, long delay, TimeUnit unit)\n{\n    user.openPrivateChannel().queueAfter(delay, unit,\n        (channel) -&gt; channel.sendMessage(reminder).queue()\n    );\n}\n</code></pre> <p>Example <code>submitAfter</code></p> <pre><code>private Map&lt;String, DelayedCompletableFuture&lt;Message&gt;&gt; tasks = new HashMap&lt;&gt;();\n\npublic ScheduledFuture&lt;Message&gt; sendWithTask(MessageChannel channel, String message)\n{\n    DelayedCompletable&lt;Message&gt; task = channel.sendMessage(message).submitAfter(5, TimeUnit.SECONDS);\n    return task;\n}\n\npublic void doSomething(MessageChannel channel, String message)\nthrows Exception\n{\n    tasks.add(channel.getId(), sendWithTask(channel, message));\n    for (DelayedCompletable&lt;Message&gt; task : tasks.values())\n    {\n        // non-blocking alternative is `thenAccept`\n        System.out.printf(\"Task completed: %s\\n\", task.get());\n    }\n}\n</code></pre>"}]}